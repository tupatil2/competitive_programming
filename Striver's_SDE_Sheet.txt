ARRAYS/MATHS

1. Sort Colors 0s, 1s, 2s

Time: O(N), Space: O(1)

public void sortColors(int[] nums) {
	int n = nums.length;
	int start = 0;
	int end = n-1;
	int index = 0;
	while(index <= end){
		if(nums[index] == 0){
			int temp = nums[start];
			nums[start] = nums[index];
			nums[index] = temp;
			index++;
			start++;
		}
		else if(nums[index] == 2){
			int temp = nums[end];
			nums[end] = nums[index];
			nums[index] = temp;
			end--;
		}
		else {
			index++;    
		}
	}
}


2. Missing & Repeating Numbers In An Array

Using XOR
Time: O(N), Space: O(1)

int[] findTwoElement(int arr[], int n) {
	int[] res = new int[2];
	
	// Xor 1..n and ele of arr
	int xor = 0;
	for(int i = 0; i < n; i++){
		xor ^= (i+1);
	}
	for(int i = 0; i < n; i++){
		xor ^= arr[i];
	}
	
	// x^y = xor where x is missing, y is repeating
	// now extract the val
	
    int msb = (int)(Math.log(xor)/Math.log(2));
	
	int num1 = 0; // if msb is set then this
	int num2 = 0; // else this
	
	for(int i = 0; i < n; i++){
		if((arr[i]&(1<<msb)) != 0){
			num1 ^= arr[i];
		}
		else {
			num2 ^= arr[i];
		}
	}
	
	for(int i = 0; i < n; i++){
		int num = i+1;
		if((num&(1<<msb)) != 0){
			num1 ^= num;
		}
		else {
			num2 ^= num;
		}
	}
	
	// check which is missing and repeating
	int c1 = 0, c2 = 0;
	for(int i = 0; i < n; i++){
		if(arr[i] == num1) c1++;
		if(arr[i] == num2) c2++;
	}
	
	if(c1 == 2){
		res[0] = num1;
		res[1] = num2;
	}
	else {
		res[0] = num2;
		res[1] = num1;
	}
	
	return res;
}

3. Merge two sorted Arrays without extra space

Time: (N+M)log(N+M), Space: O(1)

static int nextGap(int gap){
	if(gap <= 1) return 0;
	return (gap+1)/2;
}

public static void merge(long arr1[], long arr2[], int n, int m) 
{
	int gap = nextGap(n+m);
	int i = 0;
	int j = 0;
	while(gap > 0){
		
		// only on left array
		for(i = 0; i + gap < n; i++){
			if(arr1[i] > arr1[i+gap]){
				long temp = arr1[i];
				arr1[i] = arr1[i+gap];
				arr1[i+gap] = temp;
			}
		}
		
		// between left & right array
		for(j = gap > n ? gap-n : 0; i < n && j < m; i++, j++){
			if(arr1[i] > arr2[j]){
				long temp = arr1[i];
				arr1[i] = arr2[j];
				arr2[j] = temp;
			}
		}
		
		// only on right array
		if(j < m){
			for(j = 0; j + gap < m; j++){
				if(arr2[j] > arr2[j+gap]){
					long temp = arr2[j];
					arr2[j] = arr2[j+gap];
					arr2[j+gap] = temp;
				}
			}
		}
		
		// decrease the gap by the factor of 2
		gap = nextGap(gap);
	}
}

	
4. Kadaneâ€™s Algorithm

Time: O(N), Space: O(1)
public int maxSubArray(int[] nums) {
	int curr = 0;
	int max = Integer.MIN_VALUE;
	int n = nums.length;
	for(int i = 0; i < n; i++){
		curr += nums[i];
		if(curr > max){
			max = curr;
		}
		if(curr < 0){
			curr = 0;
		}
	}
	return max;
}

Follow Up: https://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/

5. Merge Overlapping Subintervals

Time: O(NLogN), Space: O(N)

class Pair{
	int x;
	int y;
	public Pair(int x, int y){
		this.x = x;
		this.y = y;
	}
}
public int[][] merge(int[][] intervals) {
	int n = intervals.length;
	List<Pair> list = new ArrayList<>();
	for(int[] e : intervals){
		list.add(new Pair(e[0],e[1]));
	}
	
	Collections.sort(list, (x,y) -> x.x-y.x == 0 ? x.y-y.y : x.x-y.x);
	List<Pair> res = new ArrayList<>();
	for(int i = 0; i < n; i++){
		Pair p = list.get(i);
		int j = i+1;
		int start = p.x;
		int end = p.y;
		while(j < n){
			Pair p1 = list.get(j);
			int start1 = p1.x;
			int end1 = p1.y;
			if(start1 > end){
				break;
			}
			else {
				start = Math.min(start,start1);
				end = Math.max(end,end1);
			}
			j++;
		}
		i = j-1;
		res.add(new Pair(start,end));
	}
	int[][] resInt = new int[res.size()][2];
	for(int i = 0; i < res.size(); i++){
		Pair p = res.get(i);
		resInt[i][0] = p.x;
		resInt[i][1] = p.y;
	}
	return resInt;
}

6. Find the duplicate in an array of N+1 integers.

Proof is IMP!
Time: O(N), Space: O(1)

public int findDuplicate(int[] nums) {
	int slow = nums[0];
	int fast = nums[0];
	
	fast = nums[nums[fast]];
	slow = nums[slow];
	
	while(slow != fast){
		slow = nums[slow];
		fast = nums[nums[fast]];
	}
	
	slow = nums[0];
	while(slow != fast){
		slow = nums[slow];
		fast = nums[fast];
	}
	
	return slow;
}

7. Set Matrix Zeroes

Time: O(N^2), Space: O(1)

public void setZeroes(int[][] arr) {
	int row = arr.length;
	int col = arr[0].length;
	boolean isColZero = false;
	for(int i = 0; i < row; i++){
		if(arr[i][0] == 0) isColZero = true;
		for(int j = 1; j < col; j++){
			if(arr[i][j] == 0){
				arr[i][0] = arr[0][j] = 0;
			}
		}
	}
	
	for(int i = row-1; i >= 0; i--){
		for(int j = col-1; j >= 1; j--){
			if(arr[i][0] == 0 || arr[0][j] == 0){
				arr[i][j] = 0;
			}
		}
		if(isColZero) arr[i][0] = 0;
	}
}

8. Pascal Triangle

Time: O(N^2), Space: O(N)

public List<List<Integer>> generate(int numsRows) {
	if(numsRows == 1){
		List<List<Integer>> res = new ArrayList<>();
		List<Integer> list = new ArrayList<>();
		list.add(1);
		res.add(new ArrayList<>(list));
		return res;
	}
	
	List<List<Integer>> list = generate(numsRows-1);
	List<Integer> last = list.get(list.size()-1);
	List<Integer> ll = new ArrayList<>();
	ll.add(1);
	for(int i = 1; i < last.size(); i++){
		ll.add(last.get(i)+last.get(i-1));
	}
	ll.add(1);
	list.add(new ArrayList<>(ll));
	return list;
}

9. Next Permutation

Time: O(N), Space: O(1)

public void nextPermutation(int[] nums) {
	int n = nums.length;
	
	if(n == 1) return;
	
	int index = -1;
	for(int i = n-2; i >= 0; i--){
		if(nums[i] < nums[i+1]){
			index = i;
			break;
		}
	}
	
	if(index == -1){
		reverse(nums,0);
		return;
	}
	
	// find the nge
	int nge = Integer.MAX_VALUE;
	int ngeIndex = -1;
	for(int i = n-1; i > index; i--){
		if(nums[i] > nums[index] && nums[i] < nge){
			nge = nums[i];
			ngeIndex = i;
		}
	}
	
	// swap the index with nge
	int temp = nums[index];
	nums[index] = nums[ngeIndex];
	nums[ngeIndex] = temp;
	
	// reverse the elements after index 
	reverse(nums,index+1);
}

void reverse(int[] nums, int i){
	int j = nums.length-1;
	while(i <= j){
		int temp = nums[i];
		nums[i] = nums[j];
		nums[j] = temp;
		i++;
		j--;
	}
}

Follow Up: Previous Permutation [Same as above]

10. Inversion of Array (Using Merge Sort)

Same as Merge Sort Just one more add is there.
Time: O(NlogN), Space: O(NlogN)

public int mergeSort(int[] nums, int start, int end){
	if(start == end) return 0;
	int mid = start + (end-start)/2;
	int ans = mergeSort(nums,start,mid);
	ans += mergeSort(nums,mid+1,end);
	ans += merge(nums,start,mid,end);
	return ans;
}

public int merge(int[] nums, int start, int mid, int end){
	int ans = 0;
	int[] temp = new int[end-start+1];
	int l = start, r = mid+1;
	int index = 0;
	while(l <= mid && r <= end){
		if(nums[l] <= nums[r]){
			temp[index] = nums[l];
			index++;
			l++;
		}
		else if(nums[l] > nums[r]){
			temp[index] = nums[r];
			ans += (mid-l+1);
			index++;
			r++;
		}
	}
	while(l <= mid){
		temp[index++] = nums[l++];
	}
	while(r <= end){
		temp[index++] = nums[r++];
	}
	for(int i = start; i <= end; i++){
		nums[i] = temp[i-start];
	}
	return ans;
}


11. Stock Buy and Sell

Time: O(N), Space: O(1)

public int maxProfit(int[] prices) {
	int min = Integer.MAX_VALUE;
	int max = Integer.MIN_VALUE;
	int ans = 0;
	for(int e : prices){
		if(min > e){
			min = e;
			max = e;
		}
		max = Math.max(e,max);
		ans = Math.max(ans,max-min);
	}
	return ans;
}

Follow Up : Stock Buy and sell for multiple transactions && atmost k transactions [DP]

12. Rotate Matrix

Time: O(N^2), Space: O(1)

public void rotate(int[][] arr) {
	int row = arr.length;
	int col = arr[0].length;
	for(int i = 0; i < row; i++){
		for(int j = 0; j <= i; j++){
			int temp = arr[i][j];
			arr[i][j] = arr[j][i];
			arr[j][i] = temp;
		}
	}
	
	for(int i = 0; i < row; i++){
		int left = 0, right = col-1;
		while(left <= right){
			int temp = arr[i][left];
			arr[i][left] = arr[i][right];
			arr[i][right] = temp;
			left++;
			right--;
		}
	}
}

13. Search in a 2D matrix  

Time: O(logN), Space: O(1)
Binary Search Tree Type

public boolean searchMatrix(int[][] arr, int k) {
	int row = arr.length;
	int col = arr[0].length;
	int r = 0;
	int c = col-1;
	while(r >= 0 && r < row && c < col && c >= 0){
		if(arr[r][c] == k){
			return true;
		}
		if(arr[r][c] > k){
			c--;
		}
		else if(arr[r][c] < k){
			r++;
		}
	}
	return false;
}

14. Pow(X,n)

Time: O(logN), Space: O(1) Apart from stack space

public double myPow(double x, int n) {
	if(n == Integer.MIN_VALUE){
		n += 2;
	}
	if(n == 0){
		return 1.0;
	}
	if(n == 1){
		return x;
	}
	if(n < 0){
		double ans = myPow(x,-n);
		return 1.0/ans;
	}
	if(n%2 == 0){
		double ans = myPow(x,n/2);
		return ans*ans;
	}
	double ans = myPow(x,n/2);
	return x * ans * ans;
}

15. Majority Element (>N/2 times) [Moore's Voting Algo]

Time: O(N), Space: O(1)

public int majorityElement(int[] nums) {
	int n = nums.length;
	int ele = nums[0];
	int times = 1;
	
	for(int i = 1; i < n; i++){
		if(nums[i] == ele){
			times++;
		}
		else {
			times--;
			if(times == 0){
				ele = nums[i];
				times = 1;
			}
		}
	}
	return ele;
}

16. Majority Element (>N/3 times) 

Time: O(N), Space: O(1)

public List<Integer> majorityElement(int[] nums) {
	int n = nums.length;
	List<Integer> list = new ArrayList<>();
	// atleast 0, atmax  2
	int num1 = 0, num2 = 0, count1 = 0, count2 = 0;
	
	for(int e : nums){
		if(e == num1) count1++;
		else if(e == num2) count2++;
		else if(count1 == 0){
			count1++;
			num1 = e;
		}
		else if(count2 == 0){
			count2++;
			num2 = e;
		}
		else {
			count1--;
			count2--;
		}
	}
	
	count1 = 0;
	count2 = 0;
	for(int e : nums){
		if(e == num1) count1++;
		if(e == num2) count2++;
	}
	
	if(count1 > n/3){
		list.add(num1);
	}
	if(num1 != num2 && count2 > n/3){
		list.add(num2);
	}
	
	return list;
}

17. Grid Unique Paths

DP Solution
Time: O(N*M), Space: O(N*M)

public int uniquePaths(int m, int n) {
	int[][] dp = new int[m][n];
	for(int i = 0; i < m; i++){
		for(int j = 0; j < n; j++){
			dp[i][j] = -1;
		}
	}
	return helper(m-1,n-1,dp);
}

int helper(int m, int n, int[][] dp){
	if(m == 0 && n == 0) return 1;
	if(m < 0 || n < 0) return 0;
	if(dp[m][n] != -1) return dp[m][n];
	int op1 = helper(m-1,n,dp);
	int op2 = helper(m,n-1,dp);
	return dp[m][n] = op1 + op2;
}

Combinatorics Solution 

(Just do (m+n-2 C m-1) OR (m+n-2 C n-1))
We can notice that for every solution we are taking n-1 steps to right & m-1 steps to left, 
So in total we have m+n-2 choices and from that we have to choose m-1 OR n-1 steps.

Time: O(N), Space: O(1)

public int uniquePaths(int m, int n) {
	int N = m+n-2;
	int R = Math.min(m-1,n-1);
	
	// Smartly handle the nCr
	double res = 1;
	int numerator = N;
	for(int i = 1; i <= R; i++){
		res = res * (numerator)/i; 
		numerator--;
	}
	return (int) res;
}

      

18. Reverse Pairs

Q. Given an integer array nums, return the number of reverse pairs in the array.
A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j].

Same as merge sort, just add one more function to cal the result.
Time: O(NlogN), Space: O(NlogN)

public int mergeSort(int[] nums, int start, int end){
	if(start == end) return 0;
	int mid = start + (end-start)/2;
	int ans = mergeSort(nums,start,mid);
	ans += mergeSort(nums,mid+1,end);
	ans += merge(nums,start,mid,end);
	return ans;
}

public int merge(int[] nums, int start, int mid, int end){
	int ans = reversePairs(nums,start,mid,end);
	int[] temp = new int[end-start+1];
	int l = start, r = mid+1;
	int index = 0;
	while(l <= mid && r <= end){
		if(nums[l] <= nums[r]){
			temp[index++] = nums[l++];
		}
		else if(nums[l] > nums[r]){
			temp[index++] = nums[r++];
		}
	}
	while(l <= mid){
		temp[index++] = nums[l++];
	}
	while(r <= end){
		temp[index++] = nums[r++];
	}
	for(int i = start; i <= end; i++){
		nums[i] = temp[i-start];
	}
	return ans;
}

public int reversePairs(int[] nums, int start, int mid, int end){
	int l = start;
	int r = mid+1;
	int ans = 0;
	while(l <= mid && r <= end){
		if((long)nums[l] > 2*1l*nums[r]){
			ans += mid+1-l;
			r++;
		}
		else {
			l++;
		}
	}
	return ans;
}

BINARY TREE

1. Inorder Traversal (with recursion and without recursion)

Logic: 
Make curr pointer to root . 
Then just go left & Put it in the stack. 
If left is null then pop the stack & put in the list.
Go right.

Time: O(N), Space: O(N)

public List<Integer> inorderTraversal(TreeNode root) {
	List<Integer> list = new ArrayList<>();
	inorderTraversal(root,list);
	return list;
}

public void inorderTraversal(TreeNode root, List<Integer> list){
	// L D R
	if(root == null) return;
	TreeNode curr = root;
	Stack<TreeNode> stack = new Stack<>();
	
	while(true){
		if(curr != null){
			stack.push(curr);
			curr = curr.left;
		}
		else {
			if(stack.isEmpty()) break;
			curr = stack.pop();
			list.add(curr.val);
			curr = curr.right;
		}
	}
} 

Follow Up: Morris Traversal

2. Preorder Traversal (with recursion and without recursion)

Iterative

Logic: Just print the curr, then add RIGHT FIRST and then LEFT

Time: O(N), Space: O(N)

public List<Integer> preorderTraversal(TreeNode root) {
	List<Integer> list = new ArrayList<>();
	preorder(root,list);
	return list;
}

public void preorder(TreeNode root, List<Integer> list){
	// D L R
	if(root == null) return;
	Stack<TreeNode> stack = new Stack<>();
	stack.push(root);
	while(!stack.isEmpty()){
		TreeNode curr = stack.pop();
		list.add(curr.val);
		if(curr.right != null){
			stack.push(curr.right);
		}
		if(curr.left != null){
			stack.push(curr.left);
		}
	}
}
 
3. Postorder Traversal (with recursion and without recursion)  [TRICKYYYY] [DEKHNA PADEGA]

Iterative:

USING 2 STACK
Logic: Pop the curr & push the popped value in satck2 & Just go left and add & go right and add! 

public void postorderTraversal(TreeNode root, List<Integer> list){
	
	if(root == null) return;
	
	Stack<TreeNode> s1 = new Stack<>();
	Stack<TreeNode> s2 = new Stack<>();
	s1.add(root);
	while(!s1.isEmpty()){
		TreeNode curr = s1.pop();
		s2.add(curr);
		if(curr.left != null){
			s1.push(curr.left);
		}
		if(curr.right != null){
			s1.push(curr.right);
		}
	}
	
	while(!s2.isEmpty()){
		list.add(s2.pop().val);
	}
}

USING 1 STACK
Logic: Go left, then right and left and if over then come baack!!
Time: O(N), Space: O(N)

public void postorderTraversal(TreeNode root, List<Integer> list){
	// L R D
	if(root == null) return;
	
	TreeNode curr = root;
	Stack<TreeNode> stack = new Stack<>();
	
	while(curr != null || !stack.isEmpty()){
		if(curr != null){
			stack.push(curr);
			curr = curr.left;
		}
		else {
			TreeNode temp = stack.peek();
			temp = temp.right;
			if(temp == null){
				temp = stack.pop();
				list.add(temp.val);
				while(!stack.isEmpty() && temp == stack.peek().right){
					temp = stack.pop();
					list.add(temp.val);
				}
					
			}
			else {
				curr = temp;
			}
		}
	}
}

IMP QUESTION: FOLLOW UP: [3 IN ONE] ALL 3 TRAVERSALS IN ONE GO!

class State{
	TreeNode root;
	int state;
	public State(TreeNode root, int state){
		this.root = root;
		this.state = state;
	}
}

public List<Integer> traversal(TreeNode root) {
	
	if(root == null) return new ArrayList<>();
	
	Stack<State> stack = new Stack<>();
	stack.add(new State(root,0));
	
	List<Integer> inorder = new ArrayList<>();
	List<Integer> preorder = new ArrayList<>();
	List<Integer> postorder = new ArrayList<>();
	
	while(!stack.isEmpty()){
		State curr = stack.peek();
		if(curr.state == 0){ // preorder, inc state and add left node -- REMEMBER
			preorder.add(curr.root.val);
			curr.state++;
			if(curr.root.left != null){
				stack.add(new State(curr.root.left,0));    
			}
		}
		else if(curr.state == 1){ // inorder, inc state and go right -- REMEMBER
			inorder.add(curr.root.val);
			curr.state++;
			if(curr.root.right != null){
				stack.add(new State(curr.root.right,0));    
			}
		}
		else { // postorder, pop -- REMEMBER
			postorder.add(curr.root.val);
			stack.pop();
		}
	}
	return inorder;
}

	
4. RightView Of Binary Tree

public List<Integer> rightSideView(TreeNode root) {
	List<Integer> ans = new ArrayList<>();
	if(root == null) return ans;
	Queue<TreeNode> q = new LinkedList<>();
	q.add(root);
	while(!q.isEmpty()){
		int size = q.size();
		int last = -1;
		while(size-- > 0){
			TreeNode curr = q.poll();
			last = curr.val;
			if(curr.left != null){
				q.add(curr.left);
			}
			if(curr.right != null){
				q.add(curr.right);
			}    
		}
		ans.add(last);
	}
	return ans;
}

5. Bottom View of Binary Tree

Make sure to follow this only if Node doesn't have sign var, otherwise create node with sign var.

public ArrayList <Integer> bottomView(Node root)
{
    ArrayList<Integer> list = new ArrayList<>();
    Map<Integer,Integer> map = new HashMap<>();
    Queue<Node> q = new LinkedList<>();
    q.add(root);
    Map<Node,Integer> sign = new HashMap<>();
    sign.put(root,0);
    int min = 0;
    int max = 0;
    while(!q.isEmpty()){
        Node curr = q.poll();
        int s = sign.get(curr);
        min = Math.min(min,s);
        max = Math.max(max,s);
        map.put(s,curr.data);
        if(curr.left != null){
            sign.put(curr.left,s-1);
            q.add(curr.left);
        }
        if(curr.right != null){
            sign.put(curr.right,s+1);
            q.add(curr.right);
        }
    }
    
    for(int i = min; i <= max; i++){
        if(map.containsKey(i)){
            list.add(map.get(i));
        }
    }
    return list;
}

6. Top View of Binary Tree 

Same as Bottom View.. just few changes.

7. Level order Traversal / Level order traversal in spiral form 

Spiral/Zigzag (covers normal level order)
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
	List<List<Integer>> list = new ArrayList<>();
	if(root == null) return list;
	Queue<TreeNode> q = new LinkedList<>();
	q.add(root);
	boolean rev = false;
	while(!q.isEmpty()){
		int size = q.size();
		List<Integer> level = new ArrayList<>();
		for(int i = 0; i < size; i++){
			TreeNode curr = q.poll();
			level.add(curr.val);
			if(curr.left != null){
				q.add(curr.left);
			}
			if(curr.right != null){
				q.add(curr.right);
			}
		}
		if(rev){
			Collections.reverse(level);
		}
		list.add(new ArrayList<>(level));
		rev = !rev;
	}
	return list;
}


8. Height of a Binary Tree 
// Considered Vertices not Edges
public int maxDepth(TreeNode root) {
	if(root == null) return 0;
	if(root.left == null && root.right == null) return 1;
	int left = 1 + maxDepth(root.left);
	int right = 1 + maxDepth(root.right);
	return Math.max(left,right);
}

Follow Up: Height of binary tree where leaf nodes are connected through DLL.
Follow Up: Boundary Order Traversal

9. Diameter of Binary Tree 

int res = Integer.MIN_VALUE;
public int diameterOfBinaryTree(TreeNode root) {
	solve(root);
	return res == Integer.MIN_VALUE ? 0 : res-1;
}

int solve(TreeNode root){
	if(root == null) return 0;
	
	int left = solve(root.left);
	int right = solve(root.right);
	
	int a = left + right + 1; // make it whole
	int b = Math.max(left,right)+1; // make it a part 
	res = Math.max(res,a);
	return b;
}

10. Check if Binary tree is height balanced or not 

Logic: make int wala function

Time: O(N), Space: O(N)

public boolean isBalanced(TreeNode root) {
	return helper(root) == -1 ? false : true;
}

int helper(TreeNode root){
	if(root == null) return 0;    
	int left = helper(root.left);
	int right = helper(root.right);
	if(Math.abs(left-right) > 1 || left == -1 || right == -1){
		return -1;
	}
	return Math.max(left,right)+1;
}

11. LCA in Binary Tree 

Logic: If found then return node.
Time: O(N), Space: O(N)

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
	if(root == null || root == p || root == q){
		return root;
	}
	
	TreeNode left = lowestCommonAncestor(root.left,p,q);
	TreeNode right = lowestCommonAncestor(root.right,p,q);
	
	if(left == null){
		return right;
	}
	else if(right == null){
		return left;
	}
	else{
		return root;
	}
}

Follow Up: LCA Using Binary Lifting

12. Check if two trees are identical or not 

public boolean isSameTree(TreeNode p, TreeNode q) {
	if(p == null && q == null) return true;
	if(p == null && q != null) return false;
	if(p != null && q == null) return false;
	if(p.val != q.val) return false;
	return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
}

13. Maximum path sum 

Time: O(N), Space: O(N)

int max = Integer.MIN_VALUE;
public int maxPathSum(TreeNode root) {
	helper(root);
	return max;
}

int helper(TreeNode root){
	if(root == null) return 0;
	
	int left = helper(root.left);
	int right = helper(root.right);
	
	// take root.val or max(left,right) + root.val as a PART of diameter
	int op1 = Math.max(root.val,Math.max(left,right) + root.val);
	
	// take op1 or left + right + root.val as WHOLE diameter
	int op2 = Math.max(op1,left+right+root.val);
	
	// choose max
	max = Math.max(max,op2);
	
	return op1;
}

14. Construct Binary Tree from inorder and preorder 

Time: O(N), Space: O(N)

public TreeNode buildTree(int[] preorder, int[] inorder) {
	int n = inorder.length;
	return helper(preorder,inorder,0,n-1,0);
}

public TreeNode helper(int[] preorder, int[] inorder, int start, int end, int index){
	if(start > end || index > preorder.length) return null;
	
	TreeNode root = new TreeNode(preorder[index]);
	int currHead = preorder[index];
	int rootIdx = -1;
	for(int i = start; i <= end; i++){
		if(inorder[i] == currHead){
			rootIdx = i;
			break;
		}
	}
	
	int leftSubTreeSize = rootIdx-start;
	root.left = helper(preorder,inorder,start,rootIdx-1,index+1);
	root.right = helper(preorder,inorder,rootIdx+1,end,index+1+leftSubTreeSize); // REMEMBER
	
	return root;
}
	
15. Construct Binary Tree from Inorder and Postorder 

Time: O(N), Space: O(N)

public TreeNode buildTree(int[] inorder, int[] postorder) {
	int n = inorder.length;
	return helper(postorder,inorder,0,n-1,n-1);
}

public TreeNode helper(int[] postorder, int[] inorder, int start, int end, int index){
	if(start > end || index < 0) return null;

	TreeNode root = new TreeNode(postorder[index]);
	int currHead = postorder[index];
	int rootIdx = -1;
	for(int i = start; i <= end; i++){
		if(inorder[i] == currHead){
			rootIdx = i;
			break;
		}
	}

	int rightSubTreeSize = end-rootIdx;
	root.left = helper(postorder,inorder,start,rootIdx-1,index-1-rightSubTreeSize); // REMEMBER
	root.right = helper(postorder,inorder,rootIdx+1,end,index-1);

	return root;
}
	
	
16. Symmetric Binary Tree 

Recursive:
boolean isSymmetric(TreeNode root1, TreeNode root2){
	if(root1 == null && root2 == null) return true;
	if(root1 == null || root2 == null) return false;
	if(root1.val != root2.val) return false;
	if(root1.val != root2.val) return false;
	return isSymmetric(root1.left,root2.right) && isSymmetric(root1.right,root2.left);
}

17. Flatten Binary Tree to LinkedList [DEKH LENA OPTIMZED WALA AGAIN]

Logic: Right Left Data, ALSO PREV

Time: O(N), Space: O(N)

TreeNode prev = null;
public void flatten(TreeNode root) {
	if(root == null) return;
	
	flatten(root.right);
	flatten(root.left);
	
	root.right = prev;
	root.left = null;
	prev = root;
}
	
Logic: Just point curr's left's rightmost pointer to curr's right & then curr's right to curr's left.

Time: O(N) Space: O(1)

public void flatten(TreeNode root) {
	TreeNode curr = root;
	while(curr != null){
		if(curr.left != null){
			TreeNode prev = curr.left;
			while(prev.right != null){
				prev = prev.right;
			}
			prev.right = curr.right;
			curr.right = curr.left;    
			curr.left = null;
		}
		curr = curr.right;
	}
}

18. Check if Binary Tree is mirror of itself or not

Time: O(N), Space: O(Height Of Tree) Asssuming its a scew tree it is O(N) worst

public boolean isSymmetric(TreeNode root) {
	return isSymmetric(root.left,root.right);
}

boolean isSymmetric(TreeNode r1, TreeNode r2){
	if(r1 == null && r2 == null) return true;
	if(r1 == null || r2 == null) return false;
	if(r1.val != r2.val) return false;
	
	boolean is1 = isSymmetric(r1.left,r2.right);
	boolean is2 = isSymmetric(r1.right,r2.left);
	
	return is1 && is2;
}

BINARY SEARCH TREE

19. Populate Next Right pointers of Tree 

Logic: Iterative BFS

Time: O(N), Space: O(Height)

public Node connect(Node root) {
	if(root == null) return root;
	Queue<Node> q = new LinkedList<>();
	q.add(root);
	
	while(!q.isEmpty()){
		Node curr = q.poll();
		int size = q.size();
		if(curr.left != null){
			q.add(curr.left);
		}
		if(curr.right != null){
			q.add(curr.right);
		}
		for(int i = 0; i < size; i++){
			Node next = q.poll();
			curr.next = next;
			curr = next;
			if(curr.left != null){
				q.add(curr.left);
			}
			if(curr.right != null){
				q.add(curr.right);
			}
		}
	}
	return root;
}


20. Search given Key in BST 

Time: O(H), Space: O(H)

public TreeNode searchBST(TreeNode root, int val) {
	if(root == null) return root;
	if(root.val == val) return root;
	
	if(root.val >= val){
		return searchBST(root.left,val);
	}
	return searchBST(root.right,val);
}

21. Construct BST from given keys. 

Time: O(H), Space: O(H)

public TreeNode sortedArrayToBST(int[] nums) {
	return helper(nums,0,nums.length-1);
}

public TreeNode helper(int[] nums, int start, int end){
	if(start > end) return null;
	int mid = start + (end-start)/2;
	TreeNode root = new TreeNode(nums[mid]);
	root.left = helper(nums,start,mid-1);
	root.right = helper(nums,mid+1,end);
	return root;
}

22. Check if a BT is BST or not  

Time: O(H), Space: O(H)

public boolean isValidBST(TreeNode root) {
	return isValid(root,null,null);
}

public boolean isValid(TreeNode root, TreeNode start, TreeNode end){
	if(root == null) return true;
	
	if(start != null && root.val <= start.val) return false;
	if(end != null && root.val >= end.val) return false;
	
	return isValid(root.left,start,root) && isValid(root.right,root,end);
}
	
23. Find LCA of two nodes in BST 

Time: O(H), Space: O(H)

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
	if(root == null || root == p || root == q){
		return root;
	}
	if(p.val < root.val && q.val < root.val){
		return lowestCommonAncestor(root.left,p,q);
	}
	if(p.val > root.val && q.val > root.val){
		return lowestCommonAncestor(root.right,p,q);
	}
	return root;
}

24. Find the inorder predecessor/successor of a given Key in BST. 

Predecessor is same as successor, just change left to right and stuff like that!

Inorder Successor

Time: O(H), Space: O(H)

public Node inorderSuccessor(Node root,Node x){
  
  Node curr = find(root,x.data);
  if(curr == null){
	  return null;
  }
  
  // yah toh right k left left main
  if(curr.right != null){
	  return findMin(curr.right);
  }
  
  // yah parent
  Node successor = null;
  Node ancestor = root;
  while(ancestor != curr){
	  if(ancestor.data > curr.data){
		  successor = ancestor;
		  ancestor = ancestor.left;
	  }
	  else {
		  ancestor = ancestor.right;
	  }
  }
  return successor;
}

public Node findMin(Node curr){
	while(curr.left != null){
		curr = curr.left;
	}
	return curr;
}

public Node find(Node root, int data){
	if(root == null) return null;
	if(root.data == data) return root;
	if(root.data < data) return find(root.right,data);
	return find(root.left,data);
}

25. Floor and Ceil in a BST 

Time: O(H), Space: O(H)
Same as search in BST!

26. Find K-th smallest and K-th largest element in BST (2 different Questions) 

Kth Smallest:

Logic: INORDER TRAVERSAL -- go left to extreme and then pop left and add its right. We do this becoz we need to sort in increasing order.

Time: O(H + K), Space: O(H)

public int kthSmallest(TreeNode root, int k) {
	Stack<TreeNode> stack = new Stack<>();
	TreeNode node = root;
	while(true){
		while(node != null){
			stack.push(node);
			node = node.left;
		}
		
		k--;
		
		if(k == 0){
			return stack.peek().val;
		}
		
		node = stack.pop().right;
	}
}

Kth Largest:

REVERSE INORDER TRAVERSAL - Same but opposite as above, just go right at extreme and then left. We do this becoz we need to sort in decreasing order.

Time: O(H + K), Space: O(H)

public int kthLargest(Node root,int K) {
	Stack<Node> stack = new Stack<>();
	Node curr = root;
	while(true){
		while(curr != null){
			stack.add(curr);
			curr = curr.right;
		}
		K--;
		if(K == 0){
			return stack.peek().data;
		}
		curr = stack.pop().left;
	}
}

27. Find a pair with a given sum in BST 

Logic: 2 pointers with min stack and max stack.

Time: O(N), Space: O(H)

public boolean findTarget(TreeNode root, int k) {
	Stack<TreeNode> min = new Stack<>();
	Stack<TreeNode> max = new Stack<>();
	
	TreeNode curr = root;
	while(curr != null){
		min.add(curr);
		curr = curr.left;
	}
	curr = root;
	while(curr != null){
		max.add(curr);
		curr = curr.right;
	}
	
	TreeNode left = min.pop();
	TreeNode right = max.pop();
	
	while(true){    
		if(left == right){
			return false;
		}
		int sum = left.val + right.val;
		if(sum == k){
			return true;
		}
		else if(sum < k){
			if(left.right != null){
				left = left.right;
				while(left != null){
					min.add(left);
					left = left.left;
				}
			}
			if(min.isEmpty()) break;
			left = min.pop();
		}
		else {
			if(right.left != null){
				right = right.left;
				while(right != null){
					max.add(right);
					right = right.right;
				}
			}
			if(max.isEmpty()) break;
			right = max.pop();
		}
	}
	return false;
}

28. BST iterator 

Logic: idea is to do partial inorder and go full to left then right and then left again like this.

Time: O(1), Space: O(H)

class BSTIterator {
    
    Stack<TreeNode> stack;
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();
        pushLeft(root);
    }
    
    public int next() {
        TreeNode curr = stack.pop();
        pushLeft(curr.right);
        return curr.val;
    }
    
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    public void pushLeft(TreeNode node){
        while(node != null){
            stack.add(node);
            node = node.left;
        }
    }
}

29. Size of the largest BST in a Binary Tree 

Logic: Postorder traversal with Info class

Time: O(N), Space: O(H)

static class Info{
	boolean bst;
	int size;
	int min;
	int max;
	
	public Info(boolean bst, int size, int min, int max){
		this.bst = bst;
		this.size = size;
		this.min = min;
		this.max = max;
	}
	
}
static int largestBst(Node root)
{
	Info ans = helper(root);
	return ans.size;
}

static int MAX = (int)(10000000);
static int MIN = (int)(-10000000);

static Info helper(Node root){
	if(root == null) return new Info(true,0,MAX,MIN);
	
	Info left = helper(root.left);
	Info right = helper(root.right);
	
	int size = left.size + right.size;
	
	if(left.bst && right.bst && left.max < root.data && right.min > root.data){
		int minn = Math.min(root.data,Math.min(left.min,right.min));
		int maxx = Math.max(root.data,Math.max(left.max,right.max));
		return new Info(true,size+1,minn,maxx);
	}
	
	return new Info(false,Math.max(left.size,right.size),0,0);
}

30. Serialize and deserialize Binary Tree [DEKH LENA]

Time: O(N), Space: O(N)

// PREORDER TRAVERSAL

public String serialize(TreeNode root) {
	if(root == null) return "";
	Queue<TreeNode> q = new LinkedList<>();
	q.add(root);
	StringBuilder res = new StringBuilder();
	while(!q.isEmpty()){
		TreeNode curr = q.poll();
		if(curr == null){
			res.append("n ");
			continue;
		}
		
		res.append(curr.val + " ");
		q.add(curr.left);
		q.add(curr.right);
	}
	return res.toString();
}

public TreeNode deserialize(String data) {
	if(data.length() == 0) return null;
	
	String[] arr = data.split(" ");
	Queue<TreeNode> q = new LinkedList<>();
	TreeNode root = new TreeNode(Integer.parseInt(arr[0]));
	q.add(root);
	
	for(int i = 1; i < arr.length; i++){
		TreeNode par = q.poll();
		if(!arr[i].equals("n")){
			TreeNode left = new TreeNode(Integer.parseInt(arr[i]));
			par.left = left;
			q.add(left);
		}
		if(!arr[++i].equals("n")){
			TreeNode right = new TreeNode(Integer.parseInt(arr[i]));
			par.right = right;
			q.add(right);
		}
	}
	return root;
}


31. Subtree of Another Tree [ALSO DO O(N) too]

public boolean isSubtree(TreeNode root, TreeNode subRoot) {
	if(root == null) return false;
	if(isSame(root,subRoot)) return true;
	return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);
}

private boolean isSame(TreeNode s, TreeNode t) {
	if (s == null && t == null) return true;
	if (s == null || t == null) return false;
	if (s.val != t.val) return false;
	return isSame(s.left, t.left) && isSame(s.right, t.right);
}


32. Binary Tree to Double Linked List 

Logic: 
// right - next
// left - prev

Time: O(N), Space: O(H)

static Node prev = null;
static Node bToDLL(Node root)
{
	Node dummy = new Node(-1);
	
	prev = dummy;
	
	_bToDLL(root);
	
	Node head = dummy.right;
	dummy.right = null;
	head.left = null;
	
	// for circular DLL
	// prev.right = head;
	// head.left = prev;
	
	return head;
}

static void _bToDLL(Node root)
{
	
	if(root == null) return;
	
	_bToDLL(root.left);
	
	prev.right = root;
	root.left = prev;
	prev = root;
	
	_bToDLL(root.right);
	
}
	
Mixed Questions:

1. Find median in a stream of running integers. 

Logic: left.size() > right.size() && left.size()-right.size() <= 1
Time: O(N), Space: O(N)

class MedianFinder {

    PriorityQueue<Integer> left = new PriorityQueue<>((x,y) -> y-x);
    PriorityQueue<Integer> right = new PriorityQueue<>();
    
    public void addNum(int num) {
	
		// fix the num
        if(left.size() == 0 || num <= left.peek()){
            left.add(num);
        }
        else{
            right.add(num);
        }
       
		// check the size
        if(left.size() > right.size() + 1){
            right.add(left.poll());
        }
        else if(left.size() < right.size()){
            left.add(right.poll());
        }
    }
    
    public double findMedian() {
        int size = left.size() + right.size();
        if(size % 2 == 0){
            return left.peek()/2.0 + right.peek()/2.0;
        }
        else {
            return left.peek();
        }
    }
}

2. K-th largest element in a stream. 

Time: O(NlogK), Space: O(K)
 
class KthLargest {
    
	int k;
    PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
    
	public KthLargest(int k, int[] nums) {
        this.k = k;
        for(int e : nums){
            pq.add(e);
			if(pq.size() > k){
				pq.poll();
			}
        }
    }
    
    public int add(int val) {
        pq.add(val);
        while(pq.size() > k){
            pq.poll();
        }
        return pq.peek();
    }
}


3. Distinct numbers in Window. 

Logic: Using Sliding Window with MAP ONLY!

Time: O(N), Space: O(N)

public int[] dNums(int[] a, int k) {
	int n = a.length;
	int[] res = new int[n-k+1];

	Map<Integer,Integer> map = new HashMap<>();
	
	int i = 0;
	for(; i < k; i++){
		map.put(a[i],map.getOrDefault(a[i],0)+1);
	}
	
	for(; i < n; i++){
		res[i-k] = map.size();
		int first = i-k;
		if(map.containsKey(a[first])){
			int times = map.get(a[first]);
			times--;
			if(times == 0){
				map.remove(a[first]);
			}
			else {
				map.put(a[first],times);
			}
		}
		map.put(a[i],map.getOrDefault(a[i],0)+1);
	}
	
	res[n-k] = map.size();
	
	return res;
}

4. K-th largest element in an unsorted array. 

PRIORITY QUEUE APPROACH

Time: O(NlogK), Space: O(K)

public int findKthLargest(int[] nums, int k) {
	PriorityQueue<Integer> pq = new PriorityQueue<>();
	
	for(int e : nums){
		pq.add(e);
		if(pq.size() > k){
			pq.poll();
		}
	}
	
	return pq.peek();
}

QUICK SORT APPROACH

Logic: 
1. Take pivot as end.
2. Make 2 pointers; i and j.
3. if(nums[j] < pivot) swap it with ith element & i++;
4. j will get increamented every time.
5. swap end and ith element
6. voila, on the left side every element is less than nums[i] && on right side every element is greater. Recursion will handle next!

Time: Avg O(N), Space: O(1)

public int findKthLargest(int[] nums, int k) {
	int n = nums.length;
	return helper(nums, n-k, 0, n-1, n);
}

int helper(int[] nums, int k, int start, int end, int n){
	
	int pivot = nums[end];
	int i = start;
	int j = start;
	
	while(j < end){
		if(nums[j] < pivot){
			swap(nums,i,j);
			i++;
		}
		j++;
	}
	
	swap(nums,i,end);
	
	// on the left of i every element is less than nums[i] &&
	// on the right of i every element is greater than nums[i]
	
	if(i == k){
		return nums[i];
	}
	else if(i < k){
		return helper(nums,k,i+1,end,n);
	}
	else {
		return helper(nums,k,start,i-1,n);
	}
}

void swap(int[] nums, int i, int j){
	int temp = nums[i];
	nums[i] = nums[j];
	nums[j] = temp;
}

5. Flood-fill Algorithm 

Time: O(N), Space: O(N) where N -> size of array

public int[][] floodFill(int[][] arr, int sr, int sc, int newColor) {
	int color = arr[sr][sc];
	if(color == newColor) return arr;
	helper(arr,sr,sc,newColor,color);
	return arr;
}

void helper(int[][] arr, int i, int j, int newColor, int color){
	
	if(i < 0 || j < 0 || i >= arr.length || j >= arr[0].length || arr[i][j] != color) {
		return;
	}
	
	if(arr[i][j] == color){
		arr[i][j] = newColor;
	}
	
	helper(arr,i+1,j,newColor,color);
	helper(arr,i-1,j,newColor,color);
	helper(arr,i,j+1,newColor,color);
	helper(arr,i,j-1,newColor,color);
}

LINKED LIST

1. Reverse A Linked List

Time: O(N), Space: O(1)
public ListNode reverseList(ListNode head) {
	ListNode curr = head;
	ListNode prev = null;
	while(curr != null){
		ListNode next = curr.next;
		curr.next = prev;
		prev = curr;
		curr = next;
	}
	return prev;
} 

2. Find middle of LinkedList 

Time: O(N), Space: O(1)
public ListNode middleNode(ListNode head) {
	ListNode fast = head;
	ListNode slow = head;
	while(fast != null && fast.next != null){
		slow = slow.next;
		fast = fast.next.next;
	}       
	return slow;
}

3. Merge two sorted Linked List 

Recursive
Time: O(N), Space: O(N)

public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	if(l1 == null && l2 == null) return l1;
	if(l1 == null) return l2;
	if(l2 == null) return l1;
	if(l1.val <= l2.val){
		l1.next = mergeTwoLists(l1.next,l2);
		return l1;
	}
	else{
		l2.next = mergeTwoLists(l1,l2.next);
		return l2;
	}
}

Iterative (FOLLOW THIS)

Always make l1 less than l2
Time: O(N), Space: O(1)

public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	if(l1 == null) return l2;
	if(l2 == null) return l1;
	if(l1.val > l2.val){
		ListNode temp = l1;
		l1 = l2;
		l2 = temp;
	}
	ListNode head = l1;
	while(l1 != null && l2 != null){
		ListNode prev = null;
		while(l1 != null && l1.val <= l2.val){
			prev = l1;
			l1 = l1.next;
		}
		
		prev.next = l2;
		
		// swap
		ListNode temp = l1;
		l1 = l2;
		l2 = temp;
	}
	return head;
}

4. Remove N-th node from back of LinkedList 

Time: O(N), Space: O(1)

public ListNode removeNthFromEnd(ListNode head, int n) {
	ListNode res = new ListNode(0);
	res.next = head;
	ListNode fast = res;
	ListNode slow = res;
	int count = 0;
	while(count < n){
		fast = fast.next;
		count++;
	}
	while(fast.next != null){
		slow = slow.next;
		fast = fast.next;
	}
	slow.next = slow.next.next;
	return res.next;
}

5. Delete a given Node when a node is given. (0(1) solution) 

public void deleteNode(ListNode node){
	node.val = node.next.val;
	node.next = node.next.next;
}

6. Add two numbers as LinkedList 
 
Time: O(max(n,m)), Space: O(max(n,m))
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
	ListNode res = new ListNode(0);
	ListNode curr = res;
	int carry = 0;
	while(l1 != null || l2 != null){
		int v1 = l1 == null ? 0 : l1.val;
		int v2 = l2 == null ? 0 : l2.val;
		
		int sum = v1 + v2 + carry;
		int lastDigit = sum%10;
		carry = sum/10;
		
		curr.next = new ListNode(lastDigit);
		curr = curr.next;
		
		l1 = l1 == null ? null : l1.next;
		l2 = l2 == null ? null : l2.next;
	}
	if(carry != 0){
		curr.next = new ListNode(carry);
		curr = curr.next;
	}
	return res.next;
}

7. Find intersection point of Y LinkedList 

Time: O(N) Atmost 2 Iterations, Space: O(1)

public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
	if(headA == null || headB == null) return null;
	ListNode l1 = headA;
	ListNode l2 = headB;
	while(l1 != l2){
		if(l1 == null) l1 = headB;
		else l1 = l1.next;
		
		if(l2 == null) l2 = headA;
		else l2 = l2.next;
	}
	return l1;
}


8. Detect a cycle in Linked List

Time: O(N), Space: O(1)
public boolean hasCycle(ListNode head) {
	ListNode fast = head;
	ListNode slow = head;
	
	while(fast != null && fast.next != null){
		fast = fast.next.next;
		slow = slow.next;
		if(fast == slow) return true;
	}
	return false;
}

9. Reverse a LinkedList in groups of size k. (HARD)

Mainly need three pointers: prev, curr, next & dummy (as head).

Dry Run on this to understand stuff.

D -> 1 -> 2 -> 3 -> NULL
P    C    N

D -> 2 -> 1 -> 3 -> NULL
P         C    N

D -> 3 -> 2 -> 1 -> NULL
P              C     N

D -> 3 -> 2 -> 1 -> NULL
               C     N
               P


public ListNode reverseKGroup(ListNode head, int k) {
	if(head == null || k == 1)  return head;
	
	ListNode dummy = new ListNode(0);
	dummy.next = head;
	ListNode curr = dummy;
	ListNode next = dummy;
	ListNode prev = dummy;
	
	// Cal the len
	int len = 0;
	while(curr.next != null){
		len++;
		curr = curr.next;
	}
	curr = dummy;
	
	while(len >= k){
		curr = prev.next;
		next = curr.next;
		for(int i = 1; i < k; i++){
			curr.next = next.next;
			next.next = prev.next;
			prev.next = next;
			next = curr.next;
		}
		prev = curr;
		len -= k;
	}
	
	return dummy.next;
}


10. Check if a LinkedList is palindrome or not. 

Break into half & compare
Time: O(N), Space: O(1)

public boolean isPalindrome(ListNode head) {
	ListNode slow = head;
	ListNode fast = head;
	ListNode prev = null;
	while(fast != null && fast.next != null){
		fast = fast.next.next;
		prev = slow;
		slow = slow.next;
	}
	
	if(fast != null){
		prev = slow;
		slow = slow.next;
	}
	
	prev.next = null;
	slow = reverse(slow);
	fast = head; 
	
	while(slow != null){
		if(fast.val != slow.val) return false;
		fast = fast.next;
		slow = slow.next;
	}
	return true;
}

public ListNode reverseList(ListNode head) {
	ListNode curr = head;
	ListNode prev = null;
	while(curr != null){
		ListNode next = curr.next;
		curr.next = prev;
		prev = curr;
		curr = next;
	}
	return prev;
} 

11. Find the starting point of the Loop of LinkedList

Tortoise & Hare OR Same as Duplicate Element in N+1 Array
Time: O(N), Space: O(1)

public ListNode detectCycle(ListNode head) {
	ListNode fast = head;
	ListNode slow = head;
	
	while(fast != null && fast.next != null){
		fast = fast.next.next;
		slow = slow.next;
		if(slow == fast){
			slow = head;
			while(fast != slow){
				fast = fast.next;
				slow = slow.next;
			}        
			return slow;
		}
	}
	return null;
}

12. Flattening of a LinkedList 

Q.
5 -> 10 -> 19 -> 28
|    |     |     |
V    V     V     V
7    20    22    35
|          |     |
V          V     V
8          50    40
|                |
V                V
30               45

Flatten this by bottom pointer!

Time: O(Sum Of Nodes), Space: O(1) (using same pointers and same nodes)

Similar to merge two sorted linked list

Node flatten(Node root){
	if(root == null || root.next == null) return root;
	root.next = flatten(root.next);
	root = merge(root,root.next);
	return root;
}

Node merge(Node t1, Node t2){
	Node res = new Node(0);
	Node curr = res;	
	
	while(t1 != null && t2 != null){
		if(t1.data < t2.data){
			curr.bottom = t1;
			t1 = t1.bottom;
		}
		else {
			curr.bottom = t2;
			t2 = t2.bottom;
		}
		curr = curr.bottom;
	}

	if(t1 != null) curr.bottom = t1;
	else curr.bottom = t2;
	return res.bottom;
}

13. Rotate a LinkedList 

public ListNode rotateRight(ListNode head, int k) {
	if(head == null) return head;
	
	int len = 0;
	ListNode curr = head;
	while(curr != null){
		len++;
		curr = curr.next;
	}
	k %= len;
	
	if(k == 0) return head;
	
	// if k is less than length then we can easily do it in Single Pass by implementing below code only.
	
	ListNode dummy = new ListNode(0);
	dummy.next = head;
	ListNode slow = dummy;
	ListNode fast = dummy;
	
	int count = 0;
	while(count < k){
		fast = fast.next;
		count++;
	}
	
	while(fast.next != null){
		slow = slow.next;
		fast = fast.next;
	}
	
	ListNode next = slow.next;
	fast.next = head;
	slow.next = null;
	head = next;
	return head;
}

14. Clone a Linked List with random and next pointer

Step0. 1 -> 2 -> 3 -> 4
Step1. 1 -> 1 -> 2 -> 2 -> 3 -> 3 -> 4 -> 4
Step2. Make random pointer point to deep copy
Step2. 1 -> 2 -> 3 -> 4 [Deep Copy]

Time: O(N), Space: O(1) [apart from deep copy but that's fine]

public Node copyRandomList(Node head) {
	if(head == null) return head;
	Node curr = head;
	Node next = null;
	while(curr != null){
		next = curr.next;
		Node newNode = new Node(curr.val);
		curr.next = newNode;
		newNode.next = next;
		curr = next;
	}
	
	curr = head;
	while(curr != null){
		if(curr.random != null){
			curr.next.random = curr.random.next;    
		}
		curr = curr.next.next;
	}
	
	Node copyHead = head.next;
	curr = head;
	while(curr != null){
		next = curr.next.next;
		Node copy = curr.next;
		curr.next = next;
		if(next != null){
			copy.next = next.next;
		}
		curr = next;
	}
	
	return copyHead;
}


HASHING

1. 2 Sum problem

Time: O(N), Space: O(N)

public int[] twoSum(int[] nums, int target) {
	int n = nums.length;
	int[] res = new int[2];
	Map<Integer,Integer> map = new HashMap<>();
	for(int i = 0; i < n; i++){
		if(map.containsKey(target-nums[i])){
			res[0] = i;
			res[1] = map.get(target-nums[i]);
			break;
		}
		map.put(nums[i],i);
	}
	return res;
}

2. 4 Sum problem 

ITS TWO POINTER NOT HASHING!!!
Time: O(N^3), Space: O(N)

public List<List<Integer>> fourSum(int[] nums, int target) {
	Arrays.sort(nums);
	List<List<Integer>> list = new ArrayList<>();
	int n = nums.length;
	for(int i = 0; i < n; i++){
		if(i > 0 && nums[i] == nums[i-1]) continue;
		for(int j = i+1; j < n; j++){
			if(j > i+1 && nums[j] == nums[j-1]) continue;
			int sum = nums[i] + nums[j];
			int start = j+1;
			int end = n-1;
			while(start < end){
				int add = nums[start] + nums[end];
				if(sum + add == target){
					List<Integer> res = new ArrayList<>();
					res.add(nums[i]);
					res.add(nums[j]);
					res.add(nums[start]);
					res.add(nums[end]);
					list.add(new ArrayList<>(res));
					start++;
					while(start < end && nums[start-1] == nums[start]){
						start++;
					}
					end--;
					while(start < end && nums[end+1] == nums[end]){
						end--;
					}
				}
				else if(sum + add < target){
					start++;
				}
				else{
					end--;
				}
			}
		}
	}
	return list;
}

3. Longest Consecutive Sequence 

Logic: At each step just go upper and lower and remove it too.
Time: O(N), Space: O(N)

public int longestConsecutive(int[] nums) {
	int n = nums.length;
	Set<Integer> set = new HashSet<>();
	for(int e : nums) set.add(e);
	int max = 0;
	
	while(!set.isEmpty()){
		int curr = set.iterator().next();
		set.remove(curr);
		
		int len = 1;
		int lower = curr-1;
		while(set.contains(lower)){
			set.remove(lower);
			lower--;
			len++;
		}
		int upper = curr+1;
		while(set.contains(upper)){
			set.remove(upper);
			upper++;
			len++;
		}
		max = Math.max(len,max);
	}
		
	return max;
}

4. Largest Subarray with 0 sum 

Time: O(N), Space: O(N)

int maxLen(int arr[], int n)
{
	Map<Integer,Integer> map = new HashMap<>();
	map.put(0,-1);
	int sum = 0;
	int count = 0;
	for(int i = 0; i < n; i++){
		sum += arr[i];
		if(map.containsKey(sum)){
			count = Math.max(count,i-map.get(sum));
		}
		else {
			map.put(sum,i);
		}
	}
	return count;
}

Follow Up:

Subarray Sum Equals K

Count the number subarrays whose sum is k
Time: O(N), Space: O(N)

public int subarraySum(int[] nums, int k) {
	Map<Integer,Integer> map = new HashMap<>();
	
	int count = 0;
	int sum = 0;
	map.put(0,1);
	for(int i = 0; i < nums.length; i++){
		sum += nums[i];
		if(map.containsKey(sum-k)){
			count+=map.get(sum-k);
		}    
		map.put(sum,map.getOrDefault(sum,0)+1);
	}
	return count;
}

5. Count number of subarrays with given XOR(this clears a lot of problems) 

Same as above
Time: O(N), Space: O(N)

public static int helper(int[] A, int B){
	int n = A.length;
	Map<Integer,Integer> map = new HashMap<>();
	int count = 0;
	int xor = 0;
	for(int i = 0; i < n; i++){
		xor ^= A[i];
		if(map.containsKey(xor^B)){
			count += map.get(xor^B);
		}
		if(xor == B){
			count++;
		}
		map.put(xor,map.getOrDefault(xor,0)+1);
	}
	return count;
}

6. Count Number of pairs divisible by K [IMP] 

Logic: Think in terms of mod.

Time: O(N), Space: O(K)

public static int countKDivisibiles(int arr[], int n, int k) 
{ 
	int[] count = new int[k];
	
	for(int i = 0; i < n; i++){
		count[arr[i]%k]++;
	}
	
	int res = count[0] * (count[0]-1)/2;
	
	for(int i = 1; i <= k/2; i++){
		if(i == k-i){
			res += count[i] * (count[i]-1)/2;
		}
		else {
			res += count[i] * count[k-i];
		}
	}
	
	return res;
}

7. Longest substring without repeat 

Logic: Like Slding Window Using Set & Without Deque 
Time: O(N), Space: O(N)

public int lengthOfLongestSubstring(String s) {
	char[] arr = s.toCharArray();
	int n = arr.length;
	int count = 0;
	int start = 0;
	Set<Character> set = new HashSet<>();
	for(int i = 0; i < n; i++){
		if(!set.contains(arr[i])){
			set.add(arr[i]);
		}
		else {
			while(start < i && set.contains(arr[i])){
				set.remove(arr[start]);
				start++;
			}
			set.add(arr[i]);
		}
		count = Math.max(count,set.size());
	}
	return count;
}

TWO POINTER

1. 3 sum 

Same as 4 sum
Time: O(N^2), Space: O(N)

public List<List<Integer>> threeSum(int[] nums) {
	int n = nums.length;
	List<List<Integer>> res = new ArrayList<>();
	Arrays.sort(nums);
	for(int i = 0; i < n; i++){
		if(i > 0 && nums[i] == nums[i-1]) continue;
		int start = i+1;
		int end = n-1;
		while(start < end){
			int sum = nums[i] + nums[start] + nums[end];
			if(sum == 0){
				List<Integer> list = new ArrayList<>();
				list.add(nums[i]);
				list.add(nums[start]);
				list.add(nums[end]);
				res.add(new ArrayList<>(list));
				start++;
				while(start < end && nums[start] == nums[start-1]){
					start++;
				}
				end--;
				while(start < end && nums[end] == nums[end+1]){
					end--;
				}
			}
			else if(sum < 0){
				start++;
			}
			else {
				end--;
			}
		}
	}
	return res;
}

2. Trapping rainwater  

NGE, PGE
Time: O(N), Space: O(N)

public int trap(int[] arr) {
	int n = arr.length;
	
	int[] left = new int[n];
	Arrays.fill(left,-1);
	for(int i = 0; i < n; i++){
		left[i] = Math.max(arr[i],i-1 < 0 ? -1 : left[i-1]);
	}
	
	int[] right = new int[n];
	Arrays.fill(right,-1);
	for(int i = n-1; i >= 0; i--){
		right[i] = Math.max(arr[i],i+1 == n ? -1 : right[i+1]);
	}
	
	int count = 0;
	for(int i = 1; i < n-1; i++){
		int res = Math.min(left[i-1],right[i+1]) - arr[i];
		count += res < 0 ? 0 : res;
	}
	return count;
}

3. Remove Duplicate from Sorted array 

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]

Time: O(N), Space: O(1)

public int removeDuplicates(int[] nums) {
	int n = nums.length;
	int index = 1;
	for(int i = 1; i < n; i++){
		if(nums[i] == nums[i-1]) continue;
		int temp = nums[i];
		nums[index] = nums[i];
		nums[index] = temp;
		index++;
	}
	return index;
}


4. Max consecutive ones 

Time: O(N), Space: O(1)

public int findMaxConsecutiveOnes(int[] nums) {
	int n = nums.length;
	int max = 0;
	int count = 0;
	for(int i = 0; i < n; i++){
		if(nums[i] == 0){
			count = 0;
		}
		else {
			count++;
		}
		max = Math.max(count,max);
	}
	return max;
}

5. Given a 2D Boolean array where each row is sorted, find the row with the maximum number of 1s.

GREEDY

1. N meeting in one room 

Time: O(N*LogN), Space : O(N)

static class Pair{
	int start;
	int end;
	public Pair(int start, int end){
		this.start = start;
		this.end = end;
	}
}
public static int maxMeetings(int start[], int end[], int n)
{
	List<Pair> list = new ArrayList<>();
	for(int i = 0; i < n; i++){
		list.add(new Pair(start[i],end[i]));
	}
	Collections.sort(list, (x,y) -> x.end-y.end == 0 ? x.start-y.start : x.end-y.end);
	int count = 0;
	int prevEnd = -1;
	for(int i = 0; i < n; i++){
		Pair curr = list.get(i);
		if(curr.start > prevEnd){
			count++;
			prevEnd = curr.end;
		}
	}
	return count;
}

2. Minimum number of platforms required for a railway

Time: O(NLogN), Space : O(1)

static int findPlatform(int arr[], int dep[], int n)
{
	Arrays.sort(arr);
	Arrays.sort(dep);
	int ans = 1;
	int count = 1;
	int i = 1;
	int j = 0;
	while(i < n && j < n){
		if(arr[i] <= dep[j]){
			count++;
			i++;
		}
		else{
			count--;
			j++;
		}
		ans = Math.max(ans,count);
	}
	return ans;
}

3. Job sequencing Problem 

Q. Given a set of N jobs where each job has a deadline and profit associated with it. 
Each job takes 1 unit of time to complete and only one job can be scheduled at a time. 
We earn the profit if and only if the job is completed by its deadline. 
The task is to find the number of jobs done and the maximum profit.

Time: O(N*M) where M is maximum deadline, Space: O(M)
Can be optimized by disjoint set but in interview don't need to.
Idea is to finish the job at its deadline!

Job -> profit, deadline
int[] JobScheduling(Job arr[], int n)
{
	Arrays.sort(arr,(x,y) -> y.profit-x.profit);
	int max = 0;
	for(Job j : arr){
		max = Math.max(max,j.deadline);
	}
	
	int[] a = new int[max];
	Arrays.fill(a,-1);
	
	int cost = 0;
	int count = 0;
	for(int i = 0; i < n; i++){
		for(int j = arr[i].deadline-1; j >= 0; j--){
			if(a[j] == -1){
				a[j] = i;
				cost += arr[i].profit;
				count++;
				break;
			}
		}
	}
	
	return new int[]{count,cost};
}
	
4. Fractional Knapsack Problem

Time: O(N*LogN), Space: O(N)

class Pair{
	int v;
	int w;
	Double cost; // use object of Double to avoid unnecessary sorting error -- REMEMBER
	public Pair(int v, int w){
		this.v = v;
		this.w = w;
		cost = new Double((double)(v*1.0/w));
	}
}
double fractionalKnapsack(int W, Item arr[], int n) 
{
	
	List<Pair> list = new ArrayList<>();
	for(int i = 0; i < n; i++){
		Item e = arr[i];
		list.add(new Pair(e.value,e.weight));
	}
	
	Collections.sort(list, (x,y) -> y.cost.compareTo(x.cost));
	
	double count = 0;
	for(Pair p : list){
		int val = p.v;
		int wt = p.w;
		double cost = p.cost;
		if(W-wt >= 0){
			count += val;
			W -= wt;
		}
		else {
			double percent = (double)(W*1.0/wt); // IMP
			count += percent * val;
			break;
		}
	}
	
	return count;
}

5. Greedy algorithm to find minimum number of coins

Time: O(V), Space: O(V)

static int deno[] = {1, 2, 5, 10, 20, 50, 100, 500, 1000};
static int n = deno.length;
static Vector<Integer> findMin(int V)
{
	Vector<Integer> ans = new Vector<>();
	for (int i = n-1; i >= 0; i--){
		while (V >= deno[i]){
			V -= deno[i];
			ans.add(deno[i]);
		}
	}
	return ans;
}

6. Activity Selection (it is same as N meeting in one room)

Time: O(NLogN), Space : O(N)

WHOLE CODE IS ALSO SAME AS "N meeting in one room"

7. Circular Tour

Time: O(N), Space: O(1)

int tour(int p[], int d[])
{
	int n = p.length;
	int tot = 0;
	int curr = 0;
	int ans = 0;      
	for(int i = 0; i < n; i++){
		tot += p[i]-d[i];
		curr += p[i]-d[i];
		if(curr < 0){     
			curr = 0;
			ans = i+1;
		}
	}
	return tot >= 0 ? ans : -1;
}

Proof:

why sum(gas) >= sum(cost)?
without this we cannot complete the loop. Becuase our whole array will move to negative.

Following array shows the prefix sum. ith point indicates whether the value is positive or negative.
               Ans
- - - + + + -   +    + + +
sum(gas) >= sum(cost), so ans the final answer is that Ans index.
we know that only one answer exists.

why not Ans + 1? [previous values always contributes]
because we know that only there is one unique starting point. And previous values always contribute to the next values. So if Ans is contributing +ve sum then why would we take Ans+1.
It is very greedy to see that the contribution of Ans will definitely help us to get to the end point. 


8. Maximum Gap [GOOD ONE & HARD]

Concept: PigeonHole Principle

Time: O(N), Space: O(N)

public int maximumGap(int[] nums) {
	int n = nums.length;
	if(n < 2){
		return 0;
	}
	
	int max = Integer.MIN_VALUE;
	int min = Integer.MAX_VALUE;
	for(int e : nums){
		max = Math.max(e,max);
		min = Math.min(e,min);
	}
	
	// find the size of the bucket
	int bucketSize = (int)Math.ceil((max-min)*1.0/(n-1)); 
	
	
	// pigeon hole principle
	// we just need min and max value in the bucket
	int[] mini = new int[n-1];
	int[] maxi = new int[n-1];
	
	Arrays.fill(mini,Integer.MAX_VALUE);
	Arrays.fill(maxi,Integer.MIN_VALUE);
	
	for(int i = 0; i < n; i++){
		
		// ignore max and min
		if(nums[i] == max || nums[i] == min){
			continue;
		}
		
		// cal in which bucket the number will fit in
		int bucketIndex = (nums[i]-min)/bucketSize;
		
		mini[bucketIndex] = Math.min(mini[bucketIndex],nums[i]);
		maxi[bucketIndex] = Math.max(maxi[bucketIndex],nums[i]);
		
	}
	
	// Note: the elements in the same bucket will never give us the answer.
	
	int diff = 0;
	int prev = min;
	for(int i = 0; i < n-1; i++){
		int next = mini[i];
		if(next == Integer.MAX_VALUE){
			continue;
		}
		diff = Math.max(diff,next-prev);
	   prev = maxi[i];
	}
	diff = Math.max(diff,max-prev);
	
	return diff;
}

RECURSION

1. Subset Sums

Q. Given an integer array nums of unique elements, return all possible subsets (the power set).

Time: O(N * 2^N), Space: O(N * 2^N)

public List<List<Integer>> subsets(int[] nums) {
	List<List<Integer>> list = new ArrayList<>();
	int n = nums.length;
	helper(list,new ArrayList<>(),0,nums,n);
	return list;
}

void helper(List<List<Integer>> list, List<Integer> res, int index, int[] nums, int n){
	if(index == n){
		list.add(new ArrayList<>(res));
		return;
	}
	
	// Not take it
	helper(list,res,index+1,nums,n);
	
	// take it
	res.add(nums[index]);
	helper(list,res,index+1,nums,n);
	res.remove(res.size()-1);
}


2. Subset-II 

Q. Given an integer array nums that may contain duplicates, return all possible subsets (the power set).

Time: O(N * 2^N), Space: O(N * 2^N)

public List<List<Integer>> subsetsWithDup(int[] nums) {
	int n = nums.length;
	Arrays.sort(nums);
	List<List<Integer>> list = new ArrayList<>();
	helper(nums,list,new ArrayList<>(),0,n);
	return list;
}

void helper(int[] nums, List<List<Integer>> list, List<Integer> res, int index, int n){
	list.add(new ArrayList<>(res));
	for(int i = index; i < n; i++){
		if(i > index && nums[i] == nums[i-1]) continue;
		res.add(nums[i]);
		helper(nums,list,res,i+1,n);
		res.remove(res.size()-1);
	}
}


3. Combination sum-1 

Q. Given an array of distinct integers candidates and a target integer target, 
return a list of all unique combinations of candidates where the chosen numbers sum to target. 
You may return the combinations in any order. With unlimited Supply of same number.

Same As Subset-II, just change base case
Time: O(N * 2^N), Space: O(N * 2^N)

public List<List<Integer>> combinationSum(int[] arr, int k) {
	int n = arr.length;
	List<List<Integer>> res = new ArrayList<>();
	helper(res,new ArrayList<>(),0,arr,n,0,k);
	return res;
}

void helper(List<List<Integer>> res, List<Integer> list, int index, int[] arr, int n, int sum, int k){
	if(sum == k){
		res.add(new ArrayList<>(list));
	}
	if(sum > k) {
		return;
	}
	for(int i = index; i < n; i++){
		if(i > index && arr[i] == arr[i-1]) continue;
		list.add(arr[i]);
		helper(res,list,i,arr,n,sum+arr[i],k);
		list.remove(list.size()-1);
	}
}

4. Combination sum-2 

ONCE USAGE!
Same As above
Time: O(N * 2^N), Space: O(N * 2^N)

public List<List<Integer>> combinationSum2(int[] arr, int k) {
	int n = arr.length;
	Arrays.sort(arr);
	List<List<Integer>> res = new ArrayList<>();
	helper(res,new ArrayList<>(),0,arr,n,0,k);
	return res;
}

void helper(List<List<Integer>> res, List<Integer> list, int index, int[] arr, int n, int sum, int k){
	if(sum == k){
		res.add(new ArrayList<>(list));
	}
	if(sum > k) {
		return;
	}
	for(int i = index; i < n; i++){
		if(i > index && arr[i] == arr[i-1]) continue;
		list.add(arr[i]);
		helper(res,list,i+1,arr,n,sum+arr[i],k); // JUST CHANGE i to i+1;
		list.remove(list.size()-1);
	}
}

5. Palindrome Partitioning 

Time: O(N * 2^N), Space: O(N * 2^N)

public List<List<String>> partition(String s) {
	int n = s.length();
	List<List<String>> res = new ArrayList<>();
	helper(res,0,s,n,new ArrayList<>());
	return res;
}

void helper(List<List<String>> res, int start, String s, int n, List<String> list){
	if(start == n){
		if(list.size() != 0) {
			res.add(new ArrayList<>(list));
		}
		return;
	}
	for(int i = start; i < n; i++){
		if(isPalin(s.substring(start,i+1))){
			list.add(s.substring(start,i+1));
			helper(res,i+1,s,n,list);
			list.remove(list.size()-1);
		}
	}
}

boolean isPalin(String s){
	int n = s.length();
	if(n == 0) return false;
	int i = 0;
	int j = n-1;
	while(i <= j){
		if(s.charAt(i) != s.charAt(j)){
			return false;
		}
		i++;
		j--;
	}
	return true;
}

6. K-th permutation Sequence [RATED HARD BUT EASY]

/*
n = 4, k = 9
k--; [0 based]
ans = 2314

STEP 1
k = 8;

1 + {2,3,4} [0-5]

2 + {1,3,4} [6-11] SELECTED

3 + {1,2,4} [12-17]

4 + {1,2,3} [18-23]



STEP 2

k = 8%6 = 2

Select 2nd from above

1 + {3,4} [0-1]

3 + {1,4} [2-3] SELECTED

4 + {1,2} [4-5]


STEP 3

k = 2%2 = 0

Select 2nd from above

1 + {4} [0-0] SELECTED

4 + {1} [1-1]

STEP 4

k = 0%1 = 0

Select 2nd from above

{4} SELECTED

DONE!

*/

Time: O(N^2), Space: O(N)

public String getPermutation(int n, int k) { 
	List<Integer> nums = new ArrayList<>();
	int fact = 1;
	for(int i = 1; i < n; i++){
		fact *= i;
		nums.add(i);
	}
	nums.add(n);
	
	k = k-1;
	String ans = "";
	
	while(true){
		ans += nums.get(k/fact);
		nums.remove(k/fact);
		if(nums.size() == 0){
			break;
		}
		k = k%fact;
		fact = fact/nums.size();
	}
	return ans;
}


RECURSION AND BACKTRACKING

Time: O(N * 2^N), Space: O(N * 2^N)

1. Print all Permutations of a string/array

public List<List<Integer>> permute(int[] nums) {
	List<List<Integer>> res = new ArrayList<>();
	boolean[] vis = new boolean[nums.length];
	List<Integer> list = new ArrayList<>();
	helper(nums,res,list,vis);
	return res;
}

public void helper(int[] nums, List<List<Integer>> res, List<Integer> list, boolean[] vis){
	
	if(list.size() == nums.length){
		res.add(new ArrayList<>(list));
		return;
	}
	
	for(int i = 0; i < nums.length; i++){
		if(!vis[i]){
			vis[i] = true;
			list.add(nums[i]);
			helper(nums,res,list,vis);
			list.remove(list.size()-1);
			vis[i] = false;
		}
	}
}


2. N queens Problem 

Time: O(N!)

int[] rowHash = new int[50];
int[] lowerHash = new int[50];
int[] upperHash = new int[50];

public List<List<String>> solveNQueens(int n) {
	List<List<String>> res = new ArrayList<>();
	int[][] arr = new int[n][n];
	helper(arr,n,res,0);
	return res;
}

void helper(int[][] arr, int n, List<List<String>> res, int col){
	if(col == n){
		res.add(add(arr));
		return;
	}
	
	for(int row = 0; row < n; row++){
		if(valid(row,col,n)){
			rowHash[row] = 1;
			lowerHash[row+col] = 1;
			upperHash[(n-1)+(col-row)] = 1; // REMEMBER
			arr[row][col] = 1;
			
			helper(arr,n,res,col+1);
			
			rowHash[row] = 0;
			lowerHash[row+col] = 0;
			upperHash[(n-1)+(col-row)] = 0; // REMEMBER
			arr[row][col] = 0;
		}
	}
}

boolean valid(int row, int col, int n){
	if(rowHash[row] == 1) return false;
	if(lowerHash[row+col] == 1) return false;
	if(upperHash[(n-1)+(col-row)] == 1) return false;
	return true;
}

List<String> add(int[][] arr){
	List<String> res = new ArrayList<>();
	for(int i = 0; i < arr.length; i++){
		String s = "";
		for(int j = 0; j < arr[0].length; j++){
			if(arr[i][j] == 0){
				s += ".";
			}
			else {
				s += "Q";
			}
		}
		res.add(s);
	}
	return res;
}

3. Sudoku Solver

Time: 9 ^ m (m represents the number of blanks to be filled in)

boolean solve(char[][] board){
	for(int i = 0; i < 9; i++){
		for(int j = 0; j < 9; j++){
			if(board[i][j] == '.'){
				for(char k = '1'; k <= '9'; k++){
					if(isValid(i,j,board,k)){
						board[i][j] = k;
						if(solve(board)){
							return true;
						}
						board[i][j] = '.';
					}
				}
				return false;
			}
		}
	}
	return true;
}

boolean isValid(int row, int col, char[][] board, char k){
	
	for(int i = 0; i < 9; i++){
		if(board[row][i] == k) return false;
		if(board[i][col] == k) return false;
	}
	
	int r = (row/3)*3; // REMEMBER
	int c = (col/3)*3;
	
	for(int i = 0; i < 3; i++){
		for(int j = 0; j < 3; j++){
			if(board[i+r][j+c] == k){
				return false;
			}
		}
	}
	return true;
}

4. M coloring Problem 

public static boolean graphColoring(List<Integer>[] G, int[] color, int i, int C) 
{
	Arrays.fill(color,-1);
	if(helper(G, 0, color, C)) return true;
	return false;
}

static boolean helper(List<Integer>[] G, int curr, int[] color, int C){
	if(curr >= G.length) return true;
	for(int i = 1; i <= C; i++){
		if(valid(curr,G,i,color)){
			color[curr] = i;
			if(helper(G,curr+1,color,C)) return true;
			color[curr] = -1;
		}
	}
	return false;
}

static boolean valid(int curr, List<Integer>[] G, int i, int[] color){
	List<Integer> neighbours = G[curr];
	for(int e : neighbours){
		if(color[e] == i){
			return false;
		}
	}
	return true;
}
	
5. Rat in a Maze 

Time: O((N^2)^4)
Space: O(L * X), L = length of the path, X = number of paths.

public static ArrayList<String> findPath(int[][] m, int n) {
	ArrayList<String> list = new ArrayList<>();
	helper(0,0,n,m,"",list);
	Collections.sort(list, (x,y) -> x.compareTo(y));
	return list;
}

static void helper(int i, int j, int n, int[][] m, String ans, 
					ArrayList<String> list){
	if(i < 0 || j < 0 || i >= n || j >= n || m[i][j] == 0){
		return;
	}
	if(i == n-1 && j == n-1){
		list.add(ans);
		return;
	}
	m[i][j] = 0;
	helper(i+1,j,n,m,ans+"D",list);
	helper(i,j+1,n,m,ans+"R",list);
	helper(i-1,j,n,m,ans+"U",list);
	helper(i,j-1,n,m,ans+"L",list);
	m[i][j] = 1;
}


6. Word Break (print all ways)

public List<String> wordBreak(String s, List<String> wordDict) {
	int n = s.length();
	
	Set<String> set = new HashSet<>(wordDict);
	List<List<String>> list = new ArrayList<>();
	
	helper(0,n,s,set,new ArrayList<>(),list);
	
	List<String> res = new ArrayList<>();
	for(List<String> l : list){
		String str = "";
		for(int i = 0; i < l.size(); i++){
			if(i == l.size()-1) str += l.get(i);
			else str += l.get(i) + " ";
		}
		res.add(str);
	}
	return res;
}

void helper(int start, int n, String s, Set<String> set, List<String> res, List<List<String>> list){
	if(start == n){
		if(res.size() != 0) list.add(new ArrayList<>(res));
		return;
	}
	
	for(int i = start+1; i <= n; i++){
		String substr = s.substring(start,i);
		if(set.contains(substr)){
			res.add(substr);
			helper(i,n,s,set,res,list);
			res.remove(res.size()-1);
		}
	}
}

7. Surrounded Region

Logic: Boundary DFS
Time: O(N^2) 
Space: O(1)

Given:

["X","X","X","X"]
["X","O","O","X"]
["X","X","O","X"]
["X","O","X","X"]

Ans:

["X","X","X","X"]
["X","X","X","X"]
["X","X","X","X"]
["X","O","X","X"]

public void solve(char[][] board) {
	int n = board.length;
	int m = board[0].length;
	
	for(int i = 0; i < n; i++){
		if(board[i][0] == 'O') mark(board,i,0,n,m);
		if(board[i][m-1] == 'O') mark(board,i,m-1,n,m);
	}
	
	for(int i = 0; i < m; i++){
		if(board[0][i] == 'O') mark(board,0,i,n,m);
		if(board[n-1][i] == 'O') mark(board,n-1,i,n,m);
	}
	
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(board[i][j] == 'O') board[i][j] = 'X';
			if(board[i][j] == '*') board[i][j] = 'O';
		}
	}
}

public void mark(char[][] board, int i, int j, int n, int m){
	if(i < 0 || i >= n || j < 0 || j >= m || board[i][j] != 'O'){
		return;
	}
	board[i][j] = '*';
	mark(board,i+1,j,n,m);
	mark(board,i-1,j,n,m);
	mark(board,i,j+1,n,m);
	mark(board,i,j-1,n,m);
	
}

BINARY SEARCH

1. N-th root of an integer M (use binary search) (square root, cube root, ..)

Time: O(NLogM) Space: O(1)
// nth root of integer m
public static double NthRoot(int n, int m)
{
	double start = 1.0;
	double end = m;
	double eps = (double)1e-6;
	while((end-start) > eps){
		double mid = (start + end)/2.0;
		if(multiply(mid,n,m) < m){
			start = mid;
		}
		else {
			end = mid;
		}
	}
	return end; // or we can also return start as last 5 decimal digits will be same
}

static double multiply(double mid, int n, int m){
	double ans = 1.0;
	for(int i = 0; i < n; i++){
		ans *= mid;
	}
	return ans;
}
	
2. Matrix Median

Time: O(32 * R * log(C)), Space: O(1)

int median(int arr[][], int r, int c) {
	int start = 1;
	int end = (int)(1e9);
	
	while(start <= end){
		int mid = start + (end-start)/2;
		
		int count = 0;
		for(int i = 0; i < r; i++){
			count += count(arr[i],mid);
		}
		
		if(count <= (r*c)/2) start = mid+1; // REMEMBER
		else end = mid-1;
	}
	return start;
}

int count(int[] arr, int k){
	int start = 0;
	int end = arr.length-1;
	while(start <= end){
		int mid = start + (end-start)/2;
		if(arr[mid] <= k){
			start = mid+1;
		}
		else {
			end = mid-1;
		}
	}
	return start;
}

3. Find the element that appears once in sorted array, and rest element appears twice (Binary search) 

OBSERVATION BASED
Time: O(logN), Space: O(1)

public int singleNonDuplicate(int[] nums) {
	int n = nums.length;
	if(n == 1){
		return nums[0];
	}
	if(nums[0] != nums[1]){
		return nums[0];
	}
	if(nums[n-1] != nums[n-2]){
		return nums[n-1];
	}
	
	int start = 1;
	int end = n-2;
	int ans = -1;
	while(start <= end){
		int mid = start + (end-start)/2;
		if(nums[mid] != nums[mid+1] && nums[mid] != nums[mid-1]){
			ans = mid;
			break;
		}
		if(nums[mid] == nums[mid-1]){
			if(mid%2 == 0){
				end = mid-1;
			}
			else {
				start = mid+1;
			}
		}
		else {
		   if(mid%2 == 1){
				end = mid-1;
			}
			else {
				start = mid+1;
			} 
		}
	}
	return nums[ans];
}

4. Search element in a sorted and rotated array/ find pivot where it is rotated (With Distinct Elements)

Time: O(NlogN), Space: O(1)

public int search(int[] nums, int target) {
	int n = nums.length;
	int start = 0, end = n-1;

	while(start <= end){
		
		int mid = start + (end-start)/2;
		
		if(nums[mid] == target){
			return mid;
		}
		
		// check if left half is sorted
		if(nums[mid] >= nums[start]){
			if(nums[mid] >= target && target >= nums[start]){ // check if it lies in left half
				end = mid-1;
			}
			else {
				start = mid+1;
			}
		}
		else { // otherwise right half is sorted
			if(nums[mid] <= target && nums[end] >= target){ // check if it lies in right half
				start = mid+1;
			}
			else {
				end = mid-1;
			}
		}
		
	}
	return -1;
}

FOLLOW UP:
With duplicate values, check if element is present or not!
Everything is same just add two more lines!

Time: O(N) Worst Case, Space: O(1)

public boolean search(int[] nums, int target) {
	int n = nums.length;
	int start = 0, end = n-1;
	
	while(start <= end){
		
		// for duplicate values
		while(start < end && nums[start] == nums[start+1]) start++;
		while(start < end && nums[end] == nums[end-1]) end--;
		
		int mid = start + (end-start)/2;
		
		if(nums[mid] == target){
			return true;
		}
		
		// check if left half is sorted
		if(nums[mid] >= nums[start]){
			if(nums[mid] >= target && target >= nums[start]){ // check if it lies in left half
				end = mid-1;
			}
			else {
				start = mid+1;
			}
		}
		else { // otherwise right half is sorted
			if(nums[mid] <= target && nums[end] >= target){ // check if it lies in right half
				start = mid+1;
			}
			else {
				end = mid-1;
			}
		}
		
	}
	return false;
}

5. Median of 2 sorted arrays   

LOGIC: We can say that given partition is median only if l1 <= r2 && l2 <= r1

Time: O(log (min(m,n))), Space: O(1)

public double findMedianSortedArrays(int[] nums1, int[] nums2) {
	int n = nums1.length;
	int m = nums2.length;
	
	if(n > m){
		return findMedianSortedArrays(nums2,nums1);
	}
	
	int start = 0, end = n;
	while(start <= end){
		int mid = start + (end-start)/2;
		int cut1 = mid;
		int cut2 = (n+m+1)/2-cut1;
		
		int left1 = cut1-1 < 0 ? Integer.MIN_VALUE : nums1[cut1-1];
		int left2 = cut2-1 < 0 ? Integer.MIN_VALUE : nums2[cut2-1];
		
		int right1 = cut1 == n ? Integer.MAX_VALUE : nums1[cut1];
		int right2 = cut2 == m ? Integer.MAX_VALUE : nums2[cut2];
		
		if(left1 <= right2 && left2 <= right1){
			double leftMax = (double)Math.max(left1,left2);
			double rightMin = (double)Math.min(right1,right2);
			if((n+m)%2 == 0){
				return (double)(leftMax/2.0 + rightMin/2.0);
			}
			else {
				return (double) Math.max(left1,left2);
			}
		}
		else if(left1 > right2){
			end = mid-1;
		}
		else {
			start = mid+1;
		}
	}
	return -1.0;
}
	
6. K-th element of two sorted arrays 

Whole code is same as Median of two sorted arrays, just need to have one more base case.
Time: O(log (min(m,n))), Space: O(1)

public long kthElement( int nums1[], int nums2[], int n, int m, int k) {
	if(n > m){
		return kthElement(nums2,nums1,m,n,k);
	}
	
	// EXTRA CASE - if k is greater than m (k > m)
	int start = Math.max(0,k-m); 
	int end = Math.min(k,n);
	
	while(start <= end){
		int mid = start + (end-start)/2;
		
		int cut1 = mid;
		int cut2 = k - cut1;
		
		int left1 = cut1-1 < 0 ? Integer.MIN_VALUE : nums1[cut1-1];
		int left2 = cut2-1 < 0 ? Integer.MIN_VALUE : nums2[cut2-1];
		
		int right1 = cut1 >= n ? Integer.MAX_VALUE : nums1[cut1];
		int right2 = cut2 >= m ? Integer.MAX_VALUE : nums2[cut2];
		
		if(left1 <= right2 && left2 <= right1){
			return (long) Math.max(left1,left2);
		}
		else if(left1 > right2){
			end = mid-1;
		}
		else {
			start = mid+1;
		}
	}
	return (long)-1;
}
	
7. Allocate Minimum Number of Pages 

Simple BS!
Time: O(NLogM), Space: O(1)

public static int findPages(int[]A,int N,int M)
{
	int sum = 0;
	for(int e : A) sum += e;
	int start = 0;
	int end = sum;
	int ans = -1;
	while(start <= end){
		int mid = start + (end-start)/2;
		if(good(mid,A,N,M)){
			ans = mid;
			end = mid-1;
		}
		else {
			start = mid+1;
		}
	}
	return ans;
}

static boolean good(int mid, int[] A, int N, int M){
	int sum = 0;
	int students = 1;
	for(int i = 0; i < N; i++){
		if(A[i] > mid) return false;
		sum += A[i];
		if(sum > mid){
			students++;
			sum = A[i];
		}
	}
	return students <= M ? true : false;
}


8. Aggressive Cows 

Time: O(NlogM) where M is diff b/w min and max element
Space: O(1)

static long helper(long[] a, int n, int c){
	sort(a);
	long start = 0;
	long end = a[n-1]-a[0]+100;
	long ans = 0;
	while(start <= end){
		long mid = start + (end-start)/2;
		if(good(mid,a,n,c)){
			ans = mid;
			start = mid+1;
		}
		else {
			end = mid-1;
		}
	}
	return ans;
}

static boolean good(long mid, long[] a, int n, int c){
	int cows = 1;
	int start = 0;
	for(int i = 1; i < n; i++){
		long diff = a[i] - a[start];
		if(diff >= mid){
			cows++;
			start = i;
		}
	}
	return cows >= c ? true : false;
}


STACK AND QUEUE 

1. Implement Stack Using Arrays 

Time: O(1), Space: O(N)

class MyStack
{
    int top;
	int arr[] = new int[1000];

    MyStack()
	{
		top = -1;
	}
	
	//Function to push an integer into the stack.
    void push(int a)
	{
	    if(top == 1000) return;
	    arr[++top] = a;
	} 
	
    //Function to remove an item from top of the stack.
	int pop()
	{
	    if(top == -1) return -1;
        return arr[top--];
	}
}

2. Implement Queue Using Arrays

Time: O(1), Space: O(N)

class MyQueue
{
    int front, rear, capacity;
	int arr[] = new int[1000];

    MyQueue()
	{
		front = rear = 0;
		capacity = 0;
	}
	
	//Function to push an integer into the stack.
    void push(int a)
	{
		if(capacity == n) return;
		arr[rear%n] = a;
		rear++;
		capacity++;
	} 
	
    //Function to remove an item from top of the stack.
	int pop()
	{
	    if(capacity == 0) return -1;
		int pop = arr[front%n];
		front++;
		capacity--;
		return pop;
	}
	
	int top()
	{
	    if(capacity == 0) return -1;
		int top = arr[front%n];
		return top;
	}
}

3. Implement Stack using Queue (using single queue)

Time: 
Push -> O(N)
All other -> O(1)

Space: O(N)

class StackUsingQueue{
    Queue<Integer> q = new LinkedList<Integer>();
     
    void push(int val)
    {
        int size = q.size();
         
        q.add(val);
         
        for (int i = 0; i < size; i++)
        {
            int x = q.remove();
            q.add(x);
        }
    }
     
    int pop()
    {
        if (q.isEmpty())
        {
            return -1;
        }
        int x = q.remove();
        return x;
    }
     
    int top()
    {
        if (q.isEmpty())
            return -1;
        return q.peek();
    }
     
    boolean isEmpty()
    {
        return q.isEmpty();
    }
 }

4. Implement Queue using Stack (0(1) amortised method)

Time: 0(1) Amortised
Space: O(2N)

class MyQueue {
    Stack<Integer> input;
    Stack<Integer> output;
    
	public MyQueue() {
        input = new Stack<>();
        output = new Stack<>();
    }
    
    public void push(int x) {
       input.push(x);
    }
    
    public int pop() {
        if(!output.isEmpty()){
            return output.pop();
        }
        else{ // transfer input to output
            while(!input.isEmpty()){
                output.push(input.pop());
            }
            return output.pop();
        } 
    }
    
    public int peek() {
        if(!output.isEmpty()){
            return output.peek();
        }
        else{ // transfer input to output
            while(!input.isEmpty()){
                output.push(input.pop());
            }
            return output.peek();
        } 
    }
    
    public boolean empty() {
        return input.isEmpty() && output.isEmpty();
    }
}	

Follow Up: Implement Queue using singly linked list

5. Check for balanced parentheses 

Time: O(N), Space: O(N)

public boolean isValid(String s) {
	Stack<Character> stack = new Stack<>();
	for(char c : s.toCharArray()){
		if(c == '(' || c == '{' || c == '['){
			stack.add(c);
		}
		else {
			if(stack.isEmpty()) return false;
			if(stack.peek() == '(' && c == ')'){
				stack.pop();
			}
			else if(stack.peek() == '{' && c == '}'){
				stack.pop();
			}
			else if(stack.peek() == '[' && c == ']'){
				stack.pop();
			}
			else {
				return false;
			}
		}
	}
	return stack.isEmpty();
}

FOLLOW UP: Given a string, find minimum number of brackets to insert to make string balanced [MUST DO!]

public int minAddToMakeValid(String s) {
	int n = s.length();
	
	int unmatachedopen = 0;
	int unmatachedclose = 0;
	
	for(int i = 0; i < n; i++){
		if(s.charAt(i) == '('){
			unmatachedopen++;
		}
		else if(unmatachedopen > 0){
			unmatachedopen--;
		}
		else {
			unmatachedclose++;
		}
	}
	
	return unmatachedopen + unmatachedclose;
}

6. Next Greater Element 

Time: O(N) && Space: O(N)

public int[] nextGreaterElements(int[] nums) {
	int n = nums.length;
	int[] arr = new int[n];
	
	Stack<Integer> stack = new Stack<>();
	
	for(int i = 2*n-1; i >= 0; i--){
		while(!stack.isEmpty() && nums[i%n] >= stack.peek()){
			stack.pop();
		}
		if(stack.isEmpty()){
			arr[i%n] = -1;
		}
		else {
			arr[i%n] = stack.peek();
		}
		stack.add(nums[i%n]);
	}
	
	return arr;
}
	
7. Sort a Stack 

Using RECURSION

static Stack<Integer> sort(Stack<Integer> s){
	if(s.isEmpty()){return s;}
	int pop = s.pop();
	Stack<Integer> sorted = sort(s);
	insert(sorted,pop);
	return sorted;
}

static void insert(Stack<Integer> stack, int ele){
	if(stack.isEmpty() || stack.peek() <= ele){
		stack.push(ele);
		return;
	}
	int pop = stack.pop();
	insert(stack,ele);
	stack.push(pop);
}

Using Iteration

public Stack<Integer> sort(Stack<Integer> s)
{
	Stack<Integer> sorted = new Stack<>();
	while(!s.isEmpty()){
		int curr = s.pop();
		while(!sorted.isEmpty() && curr < sorted.peek()){
			int pop = sorted.pop();
			s.push(pop);
		}
		sorted.push(curr);
	}
	return sorted;
}


8. Next Smaller Element 

Same as Next Smaller Element
Time: O(N), Space: O(N)

public int[] nextSmallerElements(int[] nums) {
	int n = nums.length;
	Stack<Integer> stack = new Stack<>();
	int[] arr = new int[n];
	for(int i = 2*n-1; i >= 0; i--){
		while(!stack.isEmpty() && stack.peek() >= nums[i%n]){
			stack.pop();
		}
		if(stack.isEmpty()){
			arr[i%n] = -1;
		}
		else {
			arr[i%n] = stack.peek();
		}
		stack.push(nums[i%n]);
	}
	return arr;
}

9. LRU cache (vvvv. imp) 

Logic: DLL for deletion and map for getValue
Head.next for addtion
Tail.prev for deletion

Time: O(N) for whole proccess, O(1) for get, put function
Space: O(N)

class LRUCache {
    
    class Node{
        Node next, prev;
        int key, value;
        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }
    
    Map<Integer,Node> map = new HashMap<>();
    Node head = new Node(0,0);
    Node tail = new Node(0,0);
    int capacity;
    
    public LRUCache(int _capacity) {
        capacity = _capacity;
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            remove(node);
            insert(node);
            return node.value;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if(map.containsKey(key)){
            Node node = map.get(key);
            remove(node);
        }
        if(map.size() == capacity){
            remove(tail.prev);
        }
        insert(new Node(key,value));
    }
    
    public void insert(Node node){
        map.put(node.key,node);
        
        Node headNext = head.next;
        head.next = node;
        node.next = headNext;
        headNext.prev = node;
        node.prev = head;
    }
    
    public void remove(Node node){
        map.remove(node.key);
        
        Node next = node.next;
        Node prev = node.prev;
        prev.next = next;
        next.prev = prev;
    }
}

10. LFU Cache (Hard, can be ignored) 

11. Largest rectangle in histogram (Do the one pass solution) 

Two pass: 

Time: O(2N), Space: O(N)

public int largestRectangleArea(int[] arr) {
	int n = arr.length;
	
	int[] nse = new int[n];
	Stack<Integer> stack = new Stack<>();
	for(int i = n-1; i >= 0; i--){
		while(!stack.isEmpty() && arr[stack.peek()] >= arr[i]){
			stack.pop();
		}
		if(stack.isEmpty()) nse[i] = n;
		else nse[i] = stack.peek();
		stack.push(i);
	}
	
	int[] pse = new int[n];
	stack = new Stack<>();
	for(int i = 0; i < n; i++){
		while(!stack.isEmpty() && arr[stack.peek()] >= arr[i]){
			stack.pop();
		}
		if(stack.isEmpty()) pse[i] = -1;
		else pse[i] = stack.peek();
		stack.push(i);
	}

	
	int max = 0;
	for(int i = 0; i < n; i++){
		int area = arr[i] * (nse[i]-pse[i]-1);
		max = Math.max(area,max);
	}
	
	return max;
}

One pass: [ONLY IF INTERVIEWER ASKS TO OPTIMIZE!!!]

Time: O(N), Space: O(N)

public int largestRectangleArea(int[] arr) {
    int n = arr.length;
    int max = 0;    
    int[] pse = new int[n];
    int[] nse = new int[n];
    Stack<Integer> stack = new Stack<>();

    for(int i = 0; i <= n; i++){
        
		while(!stack.isEmpty() && (i == n || arr[stack.peek()] >= arr[i])) {
            int index = stack.pop();
            int pop = arr[index];
            nse[index] = i;
            pse[index] = stack.isEmpty() ? -1 : stack.peek();
            int area = (nse[index]-pse[index]-1) * pop;
            max = Math.max(max,area);
        }

        stack.push(i);
    }

    return max;
} 

12. Sliding Window maximum 

Logic: Arrange nums in decreasing order and put index instead of numbers
Time: O(N), Space: O(K)

public int[] maxSlidingWindow(int[] nums, int k) {
	int n = nums.length;
	int[] arr = new int[n-k+1];
	
	Deque<Integer> dq = new ArrayDeque<>();
	int i = 0;
	for(; i < k; i++){
		while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]){
			dq.pollLast();
		}
		dq.add(i);
	}
	
	for(; i < n; i++){
		arr[i-k] = nums[dq.peekFirst()];
		
		while(!dq.isEmpty() && dq.peekFirst() <= i-k){
			dq.pollFirst();
		}
		
		while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]){
			dq.pollLast();
		}
		
		dq.add(i);
	}
	
	arr[n-k] = nums[dq.peekFirst()];
	
	return arr;
}

13. Implement Min Stack [Do it in O(N) not in O(2N)]

Encryption: 2*val - min
Decryption: 2*min - val

Time: O(N), Space: O(N)

class MinStack {
    Stack<Long> stack;
    long min;
    public MinStack() {
        stack = new Stack<>();
        min = Long.MAX_VALUE;
    }
    
    public void push(int value) {
        long val = (long) value;
        if(stack.isEmpty()){
            min = val;
            stack.push(val);
        }
        else {
            if(val < min){
                stack.push(2*1l*val - min); // Encryption & REMEMBER
                min = val;
            }
            else {
                stack.push(val);
            }
        }
    }
    
    public void pop() {
        if(stack.isEmpty()) return;
        long curr = stack.pop();
        if(curr < min){
            min = 2*1l*min - curr; // Rollback & REMEMBER
        }
    }
    
    public int top() {
        if(stack.isEmpty()) return -1;
        long curr = stack.peek();
        if(curr < min){
            return (int)min;
        }
        return (int)curr;
    }
    
    public int getMin() {
        return (int)min;
    }
}

14. Rotten Orange (Using BFS) 

Time: O(N*M), Space: O(N*M)

int[] rows = {0,1,0,-1};
int[] cols = {1,0,-1,0};

public int orangesRotting(int[][] grid) {
	
	int n = grid.length;
	int m = grid[0].length;
	
	Queue<int[]> q = new LinkedList<>();
	
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(grid[i][j] == 2){
				q.add(new int[]{i,j,0});
			}
		}
	}
	
	int time = -1;
	
	while(!q.isEmpty()){
		int[] curr = q.poll();
		int x = curr[0], y = curr[1], t = curr[2];
		time = Math.max(time,t);
		
		for(int i = 0; i < 4; i++){
			int nextX = rows[i] + x;
			int nextY = cols[i] + y;
			if(nextX < 0 || nextY < 0 || nextX >= n || nextY >= m || grid[nextX][nextY] == 0 || grid[nextX][nextY] == 2){
				continue;
			}
			grid[nextX][nextY] = 2;
			q.add(new int[]{nextX,nextY,t+1});
		}
	}
	
	boolean ok = true;
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			if(grid[i][j] == 1){
				time = -1;
			}
			if(grid[i][j] != 0){
				ok = false;
			}
		}
	}
	
	return ok ? 0 : time;
} 

15. Stock Span Problem 

Logic: Previous Greater Element's Index is needed
Time: O(N), Space: O(N)

public static int[] calculateSpan(int arr[], int n)
{
	int[] res = new int[n];
	Stack<Integer> stack = new Stack<>();
	for(int i = 0; i < n; i++){
		while(!stack.isEmpty() && arr[stack.peek()] <= arr[i]){
			stack.pop();
		}
		if(stack.isEmpty()){
			res[i] = i+1;
		}
		else {
			res[i] = i-stack.peek();
		}
		stack.push(i);
	}
	return res;
}

16. Find maximum of minimums of every window size 

Largest rectangle in histogram Idea
Logic: nse[i]-pse[i]-1 gives us the range in which ele @ index i is smaller

Time: O(N), Space: O(N)

static long[] riddle(long[] arr) {
	int n = arr.length;
	long[] ans = new long[n];
	Arrays.fill(ans,Long.MIN_VALUE);
	
	int[] nse = new int[n];
	Stack<Integer> stack = new Stack<>();
	nse[n-1] = n;
	stack.add(n-1);
	for(int i = n-2; i >= 0; i--){
		while(!stack.isEmpty() && arr[stack.peek()] >= arr[i]){
			stack.pop();
		}
		if(stack.isEmpty()) nse[i] = n;
		else nse[i] = stack.peek();
		stack.add(i);
	}
	
	int[] pse = new int[n];
	stack = new Stack<>();
	pse[0] = -1;
	stack.add(0);
	for(int i = 1; i < n; i++){
		while(!stack.isEmpty() && arr[stack.peek()] >= arr[i]){
			stack.pop();
		}
		if(stack.isEmpty()) pse[i] = -1;
		else pse[i] = stack.peek();
		stack.add(i);
	}
	
	for(int i = 0; i < n; i++){
		int range = nse[i]-pse[i]-1;
		ans[range-1] = Math.max(ans[range-1],arr[i]);
	}
	
	// Based on the observation that as we increasing the size of the window
	// we eliminate more max values and because of that our final ans array will
	// be decreasing in nature.
	for(int i = n-2; i >= 0; i--){
		ans[i] = Math.max(ans[i],ans[i+1]);
	}
	return ans;
}

17. The Celebrity Problem 

Time: O(N), Space: O(N)

int celebrity(int arr[][], int n)
{
	Stack<Integer> stack = new Stack<>();
	for(int i = 0; i < n; i++){
		stack.add(i);
	}
	
	while(stack.size() > 1){
		int c1 = stack.pop();
		int c2 = stack.pop();
		if(arr[c1][c2] == 1){
			stack.push(c2);
		}
		else {
			stack.push(c1);
		}
	}
	
	if(stack.isEmpty()){
		return -1;
	}
	int celeb = stack.pop();
	boolean ok = true;
	for(int i = 0; i < n; i++){
		if(i == celeb) continue;
		if(arr[celeb][i] == 1 || arr[i][celeb] == 0){
			ok = false;
		}
	}
	
	if(ok){
		return celeb;
	}
	return -1;
}

IMP: Without space 
Time: O(N), Space: O(1)
Same as above 

int celebrity(int arr[][], int n)
{
	int celeb = 0;
	
	for(int i = 1; i < n; i++){
		if(arr[celeb][i] == 1 || arr[i][celeb] == 0){
			celeb = i;
		}
	}
	
	boolean ok = true;
	for(int i = 0; i < n; i++){
		if(i == celeb) continue;
		if(arr[celeb][i] == 1 || arr[i][celeb] == 0){
			ok = false;
		}
	}
	
	if(ok){
		return celeb;
	}
	return -1;
}

STRINGS

1. Reverse Words in a String

Time: O(N), Space: O(1) Inplace

public String reverseWords(String s) {
	char[] a = s.toCharArray();
	int n = a.length;
	
	// reverse string
	reverse(a,0,n-1);
	
	// reverse words
	reverseWords(a,n);
	
	return cleanSpaces(a,n);
}

void reverseWords(char[] a, int n){
	int i = 0, j = 0;
	while(i < n){
		while(i < j || (i < n && a[i] == ' ')) i++; // REMEMBER
		while(i > j || (j < n && a[j] != ' ')) j++;
		reverse(a,i,j-1);
	}
}

void reverse(char[] a, int i, int j){
	while(i < j){
		char temp = a[i];
		a[i] = a[j];
		a[j] = temp;
		i++;
		j--;
	}
}

String cleanSpaces(char[] a, int n) {
	int i = 0, j = 0;

	while(j < n){
		while(j < n && a[j] == ' '){
			j++;
		}
		while(j < n && a[j] != ' '){
			a[i] = a[j];
			i++;
			j++;
		}
		while(j < n && a[j] == ' ') {
			j++;
		}
		if(j < n){
			a[i] = ' ';
			i++;
		}                
	}

	return new String(a).substring(0, i);
  }

2. Longest Palindrome in a string 

Can be done is O(N) using Manacher's Algo, but for interview O(N^2) is fine.
Logic: Expand Around the center

Time: O(N^2), Space: O(1)

public String longestPalindrome(String s) {
	int n = s.length();
	
	int[] index = new int[2];
	int max = -1;
	
	for(int i = 0; i < n; i++){
		int[] s1 = helper(s,i,i,n);
		int[] s2 = helper(s,i,i+1,n);
		
		int size1 = s1[1]-s1[0]+1;
		int size2 = s2[1]-s2[0]+1;
		
		if(size1 > max){
			index[0] = s1[0];
			index[1] = s1[1];
			max = size1;
		}
		if(size2 > max){
			index[0] = s2[0];
			index[1] = s2[1];
			max = size2;
		}
	}
	
	if(max != -1){
		return s.substring(index[0],index[1]+1) ;
	}
	return "";
}

public int[] helper(String s, int i, int j, int n){
	while(i >= 0 && j < n){
		if(s.charAt(i) == s.charAt(j)){
			i--;
			j++;
		}
		else {
			break;
		}
	}
	return new int[] {i+1,j-1};
}
	
3. Roman Number to Integer and vice versa

Roman To Integer

Time: O(N), Space: O(1)

public int romanToInt(String s) {
	HashMap<Character,Integer> map = new HashMap<>();
	map.put('I',1);
	map.put('V',5);
	map.put('X',10);
	map.put('L',50);
	map.put('C',100);
	map.put('D',500);
	map.put('M',1000);
	int ans = 0;
	
	for(int i = 0; i <= s.length()-1; i++){
		if(i == s.length()-1) {
			ans += map.get(s.charAt(i)); 
			break;
		}
		
		int a = map.get(s.charAt(i));
		int b = map.get(s.charAt(i+1));
		
		if(a < b){
			ans -= map.get(s.charAt(i));
		} 
		else {
			ans += map.get(s.charAt(i));
		}
	}
	
	return ans;
}

Integer To Roman

Time: O(1), Space: O(1)

public String intToRoman(int num) {
	String M[] = {"", "M", "MM", "MMM"};
	String C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
	String X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
	String I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
	
	return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
}

4. Implement ATOI/STRSTR 

Time: O(N), Space: O(1)

public int myAtoi(String str) {
	int index = 0, sign = 1, total = 0;
	//1. Empty string
	if(str.length() == 0) return 0;

	//2. Remove Spaces
	while(index < str.length() && str.charAt(index) == ' ')
		index ++;

	//3. Handle signs
	if(index < str.length() && (str.charAt(index) == '+' || str.charAt(index) == '-')){
		sign = str.charAt(index) == '+' ? 1 : -1;
		index ++;
	}

	//4. Convert number and avoid overflow
	while(index < str.length()){
		int digit = str.charAt(index) - '0';
		if(digit < 0 || digit > 9) break;

		//check if total will be overflow after 10 times and add digit
		if((Integer.MAX_VALUE-digit)/10 < total)
			return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;

		total = 10 * total + digit;
		index ++;
	}
	return total * sign;
}

5. Longest Common Prefix 

Time: O(S), S -> sum of all characters in string
Space: O(1)

public String longestCommonPrefix(String[] strs) {
	int n = strs.length;
	String ans = strs[0];
	
	for(int i = 1; i < n; i++){
		String curr = strs[i];
		int j = 0;
		int len = Math.min(curr.length(),ans.length());
		while(j < len){
			if(curr.charAt(j) == ans.charAt(j)){
				j++;
			}
			else {
				break;
			}
		}
		ans = ans.substring(0,j);
	}
	
	return ans;
}

6. Rabin Karp 

Time: O(N+M), Space: O(M)

static long rabinKarp(String s, String t) {
	// check how many times s occurs in t

	s = s.toLowerCase();
	t = t.toLowerCase();

	int S = s.length(), T = t.length();

	long[] power = new long[T];
	
	long p = 31;
	power[0] = 1;
	for(int i = 1; i < T; i++) {
		power[i] = (power[i-1] * p) % mod;
	}
	
	// prefix sum with hash of t string
	long[] tHash = new long[T+1];
	for(int i = 0; i < T; i++) {
		tHash[i+1] = (tHash[i] + (t.charAt(i)-'a'+1) * power[i]) % mod; 
	}

	// hash of s string
	long sHash = 0;
	for(int i = 0; i < S; i++) {
		sHash = (sHash + (s.charAt(i)-'a'+1) *  power[i]) % mod; 
	}

	long count = 0l;
	for(int i = 0; i < T; i++) {
		if(i+S > T) break;
		long curr = (tHash[i+S] - tHash[i] + mod) % mod;
		if(curr == (sHash * power[i]) % mod) {
			count++;
		}
	}
	return count;
}
 
7. Prefix Function/Z-Function

Q. Longest Prefix which is Also Suffix

Time: O(N), Space: O(N)

int[] prefixFunction(String s){
	int n = s.length();
	int[] prefix = new int[n];
	
	int i = 0;
	int j = 1;
	
	while(j < n){
		if(s.charAt(i) == s.charAt(j)){
			prefix[j] = i+1;
			i++;
			j++;
		}
		else {
			if(i != 0){ 
				i = prefix[i-1]; // REMEMBER
			}
			else {
				j++;
			}   
		}
	}
	
	return prefix;
}  

8. KMP algo 

Time: O(N+M), Space: O(N+M)

int kmp(String s, String t){
	// check first occurence of t in s
	
	int n = s.length(), m = t.length();
	
	int[] prefix = prefixFunction(t + "#" + s);
	
	int firstOccur = -1;
	
	for(int i = 0; i < prefix.length; i++){
		if(prefix[i] == m){
			firstOccur = i-m-m;
			break;
		}
	}
	
	return firstOccur;
}

int[] prefixFunction(String s){
	int n = s.length();
	int[] prefix = new int[n];
	
	int i = 0;
	int j = 1;
	
	while(j < n){
		if(s.charAt(i) == s.charAt(j)){
			prefix[j] = i+1;
			i++;
			j++;
		}
		else {
			if(i != 0){
				i = prefix[i-1];
			}
			else {
				j++;
			}   
		}
	}
	
	return prefix;
}  

9. Minimum characters needed to be inserted in the beginning to make it palindromic. 

Time: O(N^2) , Space: O(N^2)
public int minInsertions(String s) {
	int n = s.length();
	int[][] dp =  new int[n+1][n+1];
	for(int[] e : dp){
		Arrays.fill(e,-1);
	}
	int ans = helper(s,n,0,n-1,dp);
	return n-ans;
}

// Longest Palindromic Subsequence
public int helper(String s, int n, int i, int j, int[][] dp){
	if(i > j) return 0;
	if(i == j) return 1;
	
	if(dp[i][j] != -1) return dp[i][j];
	
	int op1 = 0;
	if(s.charAt(i) == s.charAt(j)){
		op1 = 2 + helper(s,n,i+1,j-1,dp);
	}
	
	int op2 = helper(s,n,i+1,j,dp);
	int op3 = helper(s,n,i,j-1,dp);
	
	return dp[i][j] = Math.max(op1,Math.max(op2,op3));
}

Iterative

Time: O(N^2), Space: O(N^2)

public int minInsertions(String s) {
	int n = s.length();
	int[][] dp =  new int[n+1][n+1];
	
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n; j++){
			if(s.charAt(i) == s.charAt(n-j-1)){
				dp[i+1][j+1] = 1 + dp[i][j];
			}
			else {
				dp[i+1][j+1] = Math.max(dp[i][j+1],dp[i+1][j]);
			}
		}
	}
	
	return n-dp[n][n];
}

10. Check for Anagrams 

Time: O(N), Space: O(26)

public boolean isAnagram(String s, String t) {
	int[] a = new int[26];
	
	for(char e : s.toCharArray()){
		a[e-'a']++;
	}
	
	for(char e : t.toCharArray()){
		a[e-'a']--;
	}
	
	for(int e : a){
		if(e != 0) return false;
	}
	return true;
}

11. Group Anagrams

Time: O(N*2*26), Space: O(N)

public List<List<String>> groupAnagrams(String[] strs) {
	
	Map<String,List<String>> map = new HashMap<>();
	
	for(String s : strs){
		int[] arr = new int[26];
		for(char c : s.toCharArray()){
			arr[c-'a']++;
		}
		StringBuilder code = new StringBuilder();
		for(int e : arr){
			code.append(e+"|");
		}
		map.computeIfAbsent(code.toString(),x -> new ArrayList<>());
		map.get(code.toString()).add(s);
	}
	
	return new ArrayList<>(map.values());
}

12. Count and Say 

Time: O(N*M), M -> length of string
Space: O(M)

public String countAndSay(int n) {
	if(n == 1){
		return "1";
	}
	
	String prev = countAndSay(n-1);
	int len = prev.length();
	
	StringBuilder ans = new StringBuilder();
	
	int i = 0;
	int count = 0;
	char digit = prev.charAt(i);
	
	while(i <= len){
		if(i < len && prev.charAt(i) == digit){
			count++;
			i++;
		}
		else {
			ans.append(count + "" + digit);
			if(i == len){
				break;
			}
			count = 1;
			digit = prev.charAt(i);
			i++;
		}
	}
	
	return ans.toString();
}


13. Compare version numbers 

Q. 
If version1 < version2, return -1.
If version1 > version2, return 1.
Otherwise, return 0.

Time: O(max(n,m)), Space: O(1)

public int compareVersion(String s1, String s2) {
	int m = s1.length();
	int n = s2.length();
	int i = 0;
	int j = 0;
	
	while(i < m || j < n){
		int num1 = 0;
		int num2 = 0;
		
		while(i < m && s1.charAt(i) != '.'){
			num1 = num1*10 + (s1.charAt(i)-'0');
			i++;
		}
		
		while(j < n && s2.charAt(j) != '.'){
			num2 = num2*10 + (s2.charAt(j)-'0');
			j++;
		}
		
		if(num1 < num2) return -1;
		if(num1 > num2) return 1;
		
		i++;
		j++;
	}
	
	return 0;
}

GRAPH

1. Clone a graph (Not that easy as it looks) 

Time: O(V+E), Space: O(V+E)

public Node cloneGraph(Node node) {
	if(node == null) return node;
	
	Map<Node,Node> map = new HashMap<>();
	map.put(node,new Node(node.val));
	
	Queue<Node> q = new LinkedList<>();
	q.add(node);
	
	while(!q.isEmpty()){
		Node curr = q.poll();
		
		for(Node e : curr.neighbors){
			if(!map.containsKey(e)){
				map.put(e,new Node(e.val));
				q.add(e);
			}
			map.get(curr).neighbors.add(map.get(e));
		}
	}
	
	return map.get(node);
}

Follow Up: Clone binary tree with random pointers [IMP]
	
2. DFS

Time: O(V+E), Space: O(V)

public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
	ArrayList<Integer> res = new ArrayList<>();
	boolean[] vis = new boolean[V];
	dfs(0,adj,res,vis);
	return res;
}

void dfs(int curr, ArrayList<ArrayList<Integer>> adj, ArrayList<Integer> res, boolean[] vis){
	if(vis[curr]){
		return;
	}
	vis[curr] = true;
	res.add(curr);
	ArrayList<Integer> neighbours = adj.get(curr);
	for(int e : neighbours){
		dfs(e,adj,res,vis);
	}
}
	
3. BFS

Time: O(V+E), Space: O(V)

public ArrayList<Integer> bfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
	ArrayList<Integer> res = new ArrayList<>();
	
	boolean[] vis = new boolean[V];
	Queue<Integer> q = new LinkedList<>();
	q.add(0);
	vis[0] = true;
	while(!q.isEmpty()){
		int curr = q.poll();
		res.add(curr);
		ArrayList<Integer> neighbours = adj.get(curr);
		for(int e : neighbours){
			if(!vis[e]){
				vis[e] = true;
				q.add(e);
			}
		}
	}
	
	return res;
}

	
4. Detect A cycle in Undirected Graph

Logic: DFS with Parent!

Time: O(V+E), Space: O(V+E)

public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj) {
	boolean[] vis = new boolean[V];
	for(int i = 0; i < V; i++){
		if(!vis[i]){
			if(helper(i,V,adj,-1,vis)){
				return true;
			}
		}
	}
	return false;
}

public boolean helper(int curr, int V, ArrayList<ArrayList<Integer>> adj, int par, boolean[] vis){
	ArrayList<Integer> neighbours = adj.get(curr);
	vis[curr] = true;
	for(int e : neighbours){
		if(e == par) continue;
		if(vis[e]) return true;
		if(helper(e,V,adj,curr,vis)){
			return true;
		}
	}    
	return false;
}

5. Detect A cycle in Directed Graph

Logic: Topo Sort - 
For Cyclic Graph -> after some (possibly 0) iterations, we will not find any node with 0 indegree. So, count will not be equal to V
For ACyclic Graph -> count will be V ALWAYS!!!

Time: O(V+E), Space: O(V)

public boolean isCyclic(int V, ArrayList<ArrayList<Integer>> adj) {
	int[] res = new int[V];
	int[] indegree = new int[V];
	for(int i = 0; i < V; i++){
		ArrayList<Integer> neighbours = adj.get(i);
		for(int e : neighbours){
			indegree[e]++;
		}
	}
	
	Queue<Integer> q = new LinkedList<>();
	for(int i = 0; i < V; i++){
		if(indegree[i] == 0){
			q.add(i);
		}
	}
	
	int count = 0;
	while(!q.isEmpty()){
		count++;
		int curr = q.poll();
		for(int e : adj.get(curr)){
			indegree[e]--;
			if(indegree[e] == 0){
				q.add(e);
			}
		}
	}
	
	return count != V;
}
	
6. Topo Sort 

Time: O(V+E), Space: O(V)

static int[] topoSort(int V, ArrayList<ArrayList<Integer>> adj) 
{
	int index = 0;
	int[] res = new int[V];
	
	int[] indegree = new int[V];
	
	for(int i = 0; i < V; i++){
		for(int e : adj.get(i)){
			indegree[e]++;
		}
	}
	
	Queue<Integer> q = new LinkedList<>();
	for(int i = 0; i < V; i++){
		if(indegree[i] == 0){
			q.add(i);
		}
	}
	
	while(!q.isEmpty()){
		int curr = q.poll();
		res[index++] = curr;
		for(int e : adj.get(curr)){
			indegree[e]--;
			if(indegree[e] == 0){
				q.add(e);
			}
		}
	}
	
	return res;
}

7. Number of islands (Do in Grid and Graph both) 

Time: O(N*M), Space: O(N*M)

public int numIslands(char[][] grid) {
	int rows = grid.length;
	int cols = grid[0].length;
	int count = 0;
	for(int i = 0; i < rows; i++){
		for(int j = 0; j < cols; j++){
			if(grid[i][j] == '1'){
				count++;
				helper(grid,i,j,rows,cols);     
			}
		}
	}
	return count;
}

public void helper(char[][] grid, int i, int j, int rows, int cols){
	if(i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] == '0'){
		return;
	}
	grid[i][j] = '0';
	helper(grid,i+1,j,rows,cols);
	helper(grid,i-1,j,rows,cols);
	helper(grid,i,j+1,rows,cols);
	helper(grid,i,j-1,rows,cols);
}

8. Bipartite Check 

Logic: Pick the color of next node in current iteration only!
Time: O(N*M), Space: O(N*M)

boolean dfs(List<List<Integer>> list, int curr, boolean[] vis, int V, int newColor, int[] color){
	if(color[curr] != 0){
		return color[curr] == newColor;
	}
	vis[curr] = true;
	color[curr] = newColor;
	for(int e : list.get(curr)){
		if(!dfs(list,e,vis,V,newColor == 1 ? 2 : 1, color)){
			return false;
		}
	}
	return true;
}

9. SCC(using KosaRajuâ€™s algo) 

Logic:
1. Do topo sort with DFS
2. transpose the graph
3. DFS on transpose with topo's stack

Time: O(V+E), Space: O(V+E)

public int kosaraju(int V, ArrayList<ArrayList<Integer>> adj)
{
	// topo sort
	int[] vis = new int[V];
	Stack<Integer> stack = new Stack<>();
	for(int i = 0; i < V; i++){
		if(vis[i] == 0){
			dfsForTopo(i,V,adj,stack,vis);
		}
	}
	
	// transpose the graph
	ArrayList<ArrayList<Integer>> transpose = new ArrayList<>();
	for(int i = 0; i < V; i++) transpose.add(new ArrayList<>());
	
	for(int i = 0; i < V; i++){
		vis[i] = 0;
		for(int e : adj.get(i)){
			transpose.get(e).add(i);
		}
	}
	
	// DFS on transpose with topo's stack
	int count = 0;
	while(!stack.isEmpty()){
		int curr = stack.pop();
		if(vis[curr] == 0){
			count++;
			revDfs(curr,transpose,vis);
			// System.out.println();
		}
	}
	
	return count;
}

public void revDfs(int curr, ArrayList<ArrayList<Integer>> transpose, int[] vis){
	vis[curr] = 1;
	// prints nodes
	// System.out.print(curr + " ");
	for(int e : transpose.get(curr)){
		if(vis[e] == 0){
			revDfs(e,transpose,vis);
		}
	}
}

public void dfsForTopo(int curr, int V, ArrayList<ArrayList<Integer>> adj, Stack<Integer> stack, int[] vis){
	vis[curr] = 1;
	for(int e : adj.get(curr)){
		if(vis[e] == 0){
			dfsForTopo(e,V,adj,stack,vis);
		}
	}
	stack.add(curr);
}

10. Djisktraâ€™s Algorithm 

Doesn't work for negative weights

Logic: Node(Vertex, Distance), BFS, PQ

Time: O((N+E)logN), Space: O(N)

static class Node{
	int v;
	int w;
	public Node(int v, int w){
		this.v = v;
		this.w = w;
	}
	
	public int getW(){
		return w;
	}
	
	public int getV(){
		return v;
	}
}
static int[] dijkstra(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj, int S)
{
	ArrayList<ArrayList<Node>> list = new ArrayList<>();
	for(int i = 0; i < V; i++){
		list.add(new ArrayList<Node>());
	}
	int node = 0;
	for(ArrayList<ArrayList<Integer>> e1 : adj){
		for(ArrayList<Integer> e2 : e1){
			list.get(node).add(new Node(e2.get(0),e2.get(1)));
		}
		node++;
	}
	
	// Main Dijkstra Code
	int[] dist = new int[V];
	Arrays.fill(dist,Integer.MAX_VALUE);
	dist[S] = 0;
	PriorityQueue<Node> pq = new PriorityQueue<>((x,y) -> x.w-y.w);
	pq.add(new Node(S,0));
	
	while(!pq.isEmpty()){
		Node curr = pq.poll();
		int v = curr.getV();
		for(Node it : list.get(v)){
			if(dist[v] + it.getW() < dist[it.getV()]){
				dist[it.getV()] = dist[v] + it.getW();
				pq.add(new Node(it.getV(),dist[it.getV()]));
			}
		}
	}
	return dist;
}
	
11. Bellman Ford Algo 

Helps in detecting negative cycle.
Works with negative edges.

Logic: Just relax every edge N-1 times. Relax means dist calculation.

Time: O(N*M), Space: O(N)

public int isNegativeWeightCycle(int n, int[][] arr)
{
	int len = arr.length;
	int[] dist = new int[n];
	Arrays.fill(dist,Integer.MAX_VALUE);
	dist[0] = 0;
	
	for(int i = 0; i < n-1; i++){
		for(int j = 0; j < len; j++){
			int u = arr[j][0];
			int v = arr[j][1];
			int w = arr[j][2];
			if(dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]){
				dist[v] = dist[u] + w;
			}
		}
	}
	
	for(int i = 0; i < len; i++){
		int u = arr[i][0];
		int v = arr[i][1];
		int w = arr[i][2];
		if(dist[u] + w < dist[v]){
			return 1; // negative cycle exist
		}
	}
	
	// shortest distance 
	for(int i = 0; i < len; i++){
		System.out.println(0 + " " + i + " shortest dist is " + dist[i]);
	}
	
	return 0;
}

12. Floyd Warshall Algorithm  

Q. finds the shortest path b/w all the pairs. -1 denotes that there is no edge b/w i and j in graph.

Logic: just find --> dist(i,k) + dist(k,j) < dist(i,j)
Time: O(V^3), Space: O(1)

public void shortest_distance(int[][] dist)
{
	int V = dist.length;
	for(int k = 0; k < V; k++){
		for(int i = 0; i < V; i++){
			for(int j = 0; j < V; j++){
				if(dist[i][k] == -1 || dist[k][j] == -1){ // no edges
					continue;
				}
				else if(dist[i][j] == -1){ // no direct edge 
					dist[i][j] = dist[i][k] + dist[k][j];
				}
				else if(dist[i][k] + dist[k][j] < dist[i][j]){
					dist[i][j] = dist[i][k] + dist[k][j];
				}
			}
		}
	}
}

13. MST using Primâ€™s Algo [DEKHNA PADEGA]

Time: O(NlogN), Space: O(N)

static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
{
	PriorityQueue<List<Integer>> pq = new PriorityQueue<>((x,y) -> x.get(0)-y.get(0));
	pq.add(Arrays.asList(0,0));
	boolean[] vis = new boolean[V];
	int cost = 0;
	int count = 0;
	while(count < V){
		List<Integer> curr = pq.poll();
		int w = curr.get(0);
		int pos = curr.get(1);
		
		if(vis[pos]){
			continue;
		}
		vis[pos] = true;
		cost += w;
		count++;
		for(ArrayList<Integer> arr : adj.get(pos)){
			if(!vis[arr.get(0)]){
				pq.add(Arrays.asList(arr.get(1),arr.get(0)));
			}
		}
	}
	
	return cost;
}

14. MST using Kruskalâ€™s Algo  

Logic: DSU, Node(u,v,w)
Time: O(Mlog(M)), Space: O(N)

static class Node{
	int u;
	int v;
	int wt;
	public Node(int u, int v, int wt){
		this.u = u;
		this.v = v;
		this.wt = wt;
	}
}

static int kruskals(List<Node> list){
	int n = list.size();
	
	// sort the nodes in inc order w.r.t weight
	Collections.sort(list,(x,y) -> x.wt-y.wt);
	
	// create DSU
	DSU dsu = new DSU(n);
	
	int cost = 0;
	for(Node it : list){
		int u = it.u;
		int v = it.v;
		int wt = it.wt;
		// if par is not equal, merge them.
		if(dsu.find(u) != dsu.find(v)){
			cost += wt;
			// prints edges of mst
			System.out.println(u + " " + v + " " + wt);
			dsu.merge(u,v);
		}
	}
	return cost;
}

static class DSU
{
	public int[] dsu;
	public DSU(int N){
		dsu = new int[N+1];
		for(int i=0; i <= N; i++){
			dsu[i] = i;
		}
	}
	
	//with path compression, no find by rank
	public int find(int x){
		if(dsu[x] == x) return x;
		return dsu[x] = find(dsu[x]);
	}
	
	public void merge(int x, int y){
		int fx = find(x);
		int fy = find(y);
		dsu[fx] = fy;
	}
}

15. Finding Bridges in a graph.

Logic: Beautiful concept of forward edge and back edge
Time: O(N+E), Space: O(N)

public List<List<Integer>> criticalConnections(int n, List<List<Integer>> list) {
	List<List<Integer>> res = new ArrayList<>();
	
	int[] tim = new int[n];
	int[] low = new int[n];
	
	List<List<Integer>> adj = new ArrayList<>();
	for(int i= 0; i < n; i++){
		adj.add(new ArrayList<>());
	}
	
	for(List<Integer> l : list){
		int x = l.get(0);
		int y = l.get(1);
		adj.get(x).add(y);
		adj.get(y).add(x);
	}
	
	boolean[] vis = new boolean[n];
	
	dfs(adj,res,tim,low,n,0,-1,vis,0);
	
	return res;
}

void dfs(List<List<Integer>> list, List<List<Integer>> res, int[] time, int[] low, int n, int curr, int par, boolean[] vis, int timer){
	
	vis[curr] = true;
	time[curr] = low[curr] = timer++;
	
	List<Integer> neighbours = list.get(curr);
	
	for(int e : neighbours){
		if(e == par) continue;
		
		if(vis[e]){ // we are visting the ancestor - back edge
			low[curr] = Math.min(low[curr],time[e]);
		}
		else { // forward edge
			dfs(list,res,time,low,n,e,curr,vis,timer);
			low[curr] = Math.min(low[curr],low[e]);
			if(low[e] > time[curr]){ // means the neighbour node doesn't have any connection with curr's ancestor
				List<Integer> l = new ArrayList<>();
				l.add(curr);
				l.add(e);
				res.add(new ArrayList<>(l));
			}
		}
	}
}

DYNAMIC PROGRAMMING

1. Max Product Subarray

Time: O(N), Space: O(1)  
// nums[i],nums[i]*max,nums[i]*min

public int maxProduct(int[] nums) {
	int max = nums[0]; // max till ith point
	int min = nums[0]; // min till ith point
	int n = nums.length;
	int res = max; // stores overall max
	for(int i = 1; i < n; i++){
		int temp = min;
		min = Math.min(nums[i],Math.min(nums[i]*max,nums[i]*min));
		max = Math.max(nums[i],Math.max(nums[i]*max,nums[i]*temp));
		res = Math.max(res,max);
	}
	return res;
}

2. Longest Increasing Subsequence

Time: O(N^2), Space: O(N)

DP Version: 
public int lengthOfLIS(int[] nums) {
	int n = nums.length;
	int[] dp = new int[n];
	Arrays.fill(dp,1);
	int max = 1;
	for(int i = 0; i < n; i++){
		int curr = 1;
		for(int j = 0; j < i; j++){
			if(nums[j] < nums[i]){
				curr = Math.max(curr,dp[j]+1);
			}
		}
		dp[i] = Math.max(dp[i],curr);
		max = Math.max(max,dp[i]);
	}
	return max;
}

Binary Search Version: 
Time: O(NlogN), Space: O(N)

public int lengthOfLIS(int[] nums) {
	int n = nums.length;
	List<Integer> list = new ArrayList<>();
	for(int i = 0; i < n; i++){
		int index = upperBound(list,nums[i]);
		if(index >= list.size()){
			list.add(nums[i]);
		}
		else {
			list.set(index,nums[i]);
		}
	}
	return list.size();
}

public int upperBound(List<Integer> list, int ele){
	int start = 0;
	int end = list.size()-1;
	int ans = list.size();
	while(start <= end){
		int mid = start + (end-start)/2;
		if(list.get(mid) >= ele){
			ans = mid;
			end = mid-1;
		}
		else {
			start = mid+1;
		}
	}
	return ans;
}

3. Longest Common Subsequence

Time: O(N*M), Space: O(M)

public int iterative(String t1, String t2, int n, int m){
	//same as 2d dp
	int[] curr = new int[m+1];
	int[] prev = new int[m+1];
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			if(t1.charAt(i-1) == t2.charAt(j-1)){
				curr[j] = 1 + prev[j-1];
			}
			else {
				curr[j] = Math.max(curr[j-1],prev[j]);
			}
		}
		for(int j = 0; j <= m; j++){
			prev[j] = curr[j];
		}
	}
	return curr[m];
}

Time: O(N*M), Space: O(N*M)

public int recursive(String t1, String t2, int n, int m, int i, int j, int[][] dp){
	if(i >= n || j >= m) return 0;
	if(dp[i][j] != -1) return dp[i][j];
	int op1 = Integer.MIN_VALUE;
	if(t1.charAt(i) == t2.charAt(j)){
		op1 = 1 + recursive(t1,t2,n,m,i+1,j+1,dp);
	}
	int op2 = recursive(t1,t2,n,m,i+1,j,dp);
	int op3 = recursive(t1,t2,n,m,i,j+1,dp);
	return dp[i][j] = Math.max(op1,Math.max(op2,op3));
}


4. 0/1 knapsack

Time: O(N*M), Space: O(N*M)
public static int knapsack(int[] v, int[] w, int W)
{
	int[][] T = new int[v.length + 1][W + 1];
	for (int i = 1; i <= v.length; i++){
		for (int j = 0; j <= W; j++){
			if (w[i-1] > j) {
				T[i][j] = T[i-1][j];
			}
			else {
				T[i][j] = Integer.max(T[i-1][j], T[i-1][j-w[i-1]] + v[i-1]);
			}
		}
	}
	return T[v.length][W];
}

5. Edit Distance

Recursive:
Time: O(N*M), Space: O(N*M)

int helper(String s, String t, int n, int m, int i, int j, int[][] dp){
	if(i >= n){
		return dp[i][j] = m-j;
	}
	if(j >= m){
		return dp[i][j] = n-i;
	}
	if(dp[i][j] != -1) return dp[i][j];
	int op0 = Integer.MAX_VALUE;
	if(s.charAt(i) == t.charAt(j)){
		op0 = helper(s,t,n,m,i+1,j+1,dp);
	}
	int op1 = 1 + helper(s,t,n,m,i,j+1,dp);
	int op2 = 1 + helper(s,t,n,m,i+1,j+1,dp);
	int op3 = 1 + helper(s,t,n,m,i+1,j,dp);
	return dp[i][j] = Math.min(Math.min(op0,op1),Math.min(op2,op3));
}

Iterative:
Time: O(N*M), Space: O(N*M)  

int helper(String s1, String s2){
	int l1 = s1.length(), l2 = s2.length();
	for(int x = 1; x <= l1; x++){
		dp[x][0] = x;
	}
	for(int x = 1; x <= l2; x++){
		dp[0][x] = x;
	}
	for(int i = 1; i <= l1; i++){
		for(int j = 1; j <= l2; j++){
			if(s1.charAt(i-1) == s2.charAt(j-1)){
				dp[i][j] = dp[i-1][j-1];
			}
			else {
				dp[i][j] = Math.min(dp[i][j-1]+1,Math.min(dp[i-1][j]+1,dp[i-1][j-1]+1));
			}
		}
	}
	return dp[l1][l2];
}

6. Maximum sum increasing subsequence  

Time: O(N^2), Space: O(N)

public int maxSumIS(int arr[], int n)  
{  
    int[] dp = new int[n];
    for(int i = 0; i < n; i++){
        dp[i] = arr[i];
    }
    int res = 0;
    for(int i = 0; i < n; i++){
        int max = 0;
        for(int j = 0; j < i; j++){
            if(arr[j] < arr[i]){
                max = Math.max(max,dp[j]);
            }
        }
        max += arr[i];
        dp[i] = max;
        res = Math.max(res,dp[i]);
    }
    return res;
} 

7. Matrix Chain Multiplication 

Time: O(N^3), Space: (N^2)
// call this helper(N,arr,1,n-1,dp)

static int helper(int N, int[] arr, int i, int j, int[][] dp){
	if(i == j) return 0;
	if(dp[i][j] != -1) return dp[i][j];
	int min = Integer.MAX_VALUE;
	for(int k = i; k < j; k++){ 
		int count = helper(N,arr,i,k,dp) + helper(N,arr,k+1,j,dp) + arr[i-1] * arr[k] * arr[j];
		min = Math.min(count,min);
	}
	return dp[i][j] = min;
}

8. Minimum sum path in matrix, (count paths, and similar type do, also backtrack to find the minimum path) 

Time: O(N*M), Space: O(N*M)

public int minPathSum(int[][] grid) {
	int n = grid.length;
	int m = grid[0].length;
	int[][] dp = new int[n][m];
	for(int[] e : dp) Arrays.fill(e,-1);
	int ans = helper(grid,n,m,0,0,dp);
	
	// trace the path 
	int i = n-1;
	int j = m-1;
	List<Integer> list = new ArrayList<>();
	while(i >= 0 && j >= 0){
		list.add(grid[i][j]);
		int top = Integer.MAX_VALUE;
		if(i-1 >= 0){
			top = grid[i-1][j];
		}
		int left = Integer.MAX_VALUE;
		if(j-1 >= 0){
			left = grid[i][j-1];
		}
		if(top > left){
			j--;
		}
		else {
			i--;
		}
	}
	Collections.reverse(list);
	System.out.println(list);
	return ans;
}

int helper(int[][] grid, int n, int m, int i, int j, int[][] dp){
	if(i >= n || j >= m) return Integer.MAX_VALUE-4000;
	if(i == n-1 && j == m-1) return grid[i][j];
	if(dp[i][j] != -1) return dp[i][j];
	int ans1 = grid[i][j] + helper(grid,n,m,i+1,j,dp);
	int ans2 = grid[i][j] + helper(grid,n,m,i,j+1,dp);
	return dp[i][j] = Math.min(ans1,ans2);
}

9. Coin Change

Time: O(N*M), Space: O(N*M)

public int coinChange(int[] coins, int amount) {
	int n = coins.length;
	int[][] dp = new int[n+1][amount+1];
	
	// base condtion
	for(int i = 1; i <= amount; i++){
		dp[0][i] = Integer.MAX_VALUE-1000;
	}
	
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= amount; j++){
			if(coins[i-1] <= j){
				dp[i][j] = Math.min(dp[i-1][j],1+dp[i][j-coins[i-1]]);
			}
			else {
				dp[i][j] = dp[i-1][j];
			}
		}
	}
	
	return dp[n][amount] > amount ? -1 : dp[n][amount];
}

10. Subset Sum

Time: O(N*M), Space: O(N*M)

static boolean iterative(int[] arr, int N, int sum){
	boolean[][] dp = new boolean[N+1][sum+1];
	for(int i = 0; i <= N; i++){
		for(int j = 0; j <= sum; j++){
			if(i == 0) dp[i][j] = false;
			if(j == 0) dp[i][j] = true;
		}
	}
	for(int i = 1; i <= N; i++){
		for(int j = 1; j <= sum; j++){
			if(arr[i-1] <= j){
				dp[i][j] = dp[i-1][j-arr[i-1]] || dp[i-1][j];
			}
			else {
				dp[i][j] = dp[i-1][j];
			}
		}
	}
	return dp[N][sum];
}

static int recursive(int[] arr, int N, int sum, int index){
	if(sum == 0) return dp[index][sum] = 1;
	if(index >= N || sum < 0) return 0;
	if(dp[index][sum] != -1) return dp[index][sum];
	int op1 = recursive(arr,N,sum-arr[index],index+1);
	int op2 = recursive(arr,N,sum,index+1);
	if(op1 == 1 || op2 == 1) dp[index][sum] = 1;
	else dp[index][sum] = 0;
	return dp[index][sum];
}

11. Maximum profit in Job scheduling [DEKHNA PADEGA]

LIS + Binary Search
Time: O(NlogN), Space: O(N)

class Pair{
	int start;
	int end;
	int profit;
	public Pair(int start, int end, int profit){
		this.start = start;
		this.end = end;
		this.profit = profit;
	}
}

public int jobScheduling(int[] st, int[] et, int[] p) {
	int n = st.length;
	List<Pair> list = new ArrayList<>();
	for(int i = 0; i < n; i++){
		list.add(new Pair(st[i],et[i],p[i]));
	}
	Collections.sort(list,(x,y) -> x.end-y.end);
	return helper(list,n);
}

public int helper(List<Pair> list, int n){
	int[] dp = new int[n];
	for(int i = 0; i < n; i++){
		dp[i] = list.get(i).profit;
	}
	for(int i = 0; i < n; i++){
		Pair p1 = list.get(i);
		int max = 0;
		dp[i] = Math.max(dp[i],i-1 >= 0 ? dp[i-1] : 0);
		int start = 0;
		int end = i-1;
		int ans = -1;
		while(start <= end){
			int mid = start + (end-start)/2;
			Pair p2 = list.get(mid);
			if(p1.start >= p2.end){
				ans = mid;
				start = mid+1;
			}
			else {
				end = mid-1;
			}
		}
		if(ans != -1){
			dp[i] = Math.max(dp[i],dp[ans]+p1.profit);
		}
	}
	return dp[n-1];
}

12. Word Break

Q. Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true

Time: O(N^2), Space: O(N)

public boolean wordBreak(String s, List<String> wordDict) {
	if(s.equals("")) return false;
	int n = s.length();
	boolean[] dp = new boolean[n+1];
	Set<String> set = new HashSet<>(wordDict);
	dp[0] = true;
	for(int i = 1; i <= n; i++){
		for(int j = 0; j < i; j++){
			if(dp[j] && set.contains(s.substring(j,i))){
				dp[i] = true;
				break;
			}
		}
	}
	return dp[n];
}

13. Egg Dropping

Logic: minimize the maxiumum value

Time Complexity: O(egg*floor*floor), Space: O(egg*floor)

int helper(int egg, int floor){
	if(egg == 1 || floor <= 1){
		return floor;
	}
	if(dp[egg][floor] != -1) return dp[egg][floor];
	int res = floor;
	for(int i = 1; i <= floor; i++){
		int breaks = helper(egg-1,i-1); // if breaks
		int notbreaks = helper(egg,floor-i); // not breaks
		res = Math.min(res,Math.max(breaks,notbreaks)+1);
	}
	return dp[egg][floor] = res;
}

Time Complexity: O(egg*floor*log(floor)), Space: O(egg*floor)

int helper(int egg, int floor){
	if(egg == 1 || floor <= 1){
		return floor;
	}
	if(dp[egg][floor] != -1) return dp[egg][floor];
	int res = floor;
	int start = 1;
	int end = floor;
	while(start <= end){
		int mid = start + (end-start)/2;
		int breaks = helper(egg-1,mid-1); // if breaks
		int notbreaks = helper(egg,floor-mid); // not breaks
		res = Math.min(res,Math.max(breaks,notbreaks)+1); // count result
		if(breaks < notbreaks){
			start = mid+1;
		}
		else {
			end = mid-1;
		}
	}
	return dp[egg][floor] = res;
}

14. Rod Cutting [DEKHNA PADEGA]

Time: O(N^2), Space: O(N)

public static int rodCut(int[] price, int n)
{
	// `T[i]` stores the maximum profit achieved from a rod of length `i`
	int[] T = new int[n + 1];

	// consider a rod of length `i`
	for (int i = 1; i <= n; i++){
		// divide the rod of length `i` into two rods of length `j`
		// and `i-j` each and take maximum
		for (int j = 1; j <= i; j++) {
			T[i] = Integer.max(T[i], price[j - 1] + T[i - j]);
		}
	}

	return T[n];
}

15. Palindrome Partitioning (MCM Variation) 

Logic: Just follow standard MCM pattern

Time: O(N^3), Space: O(N^2)

public int minCut(String s) {
	int n = s.length();
	int[][] dp = new int[n][n];
	for(int[] e : dp) Arrays.fill(e,-1);
	return helper(s,0,n-1,dp);
}

int helper(String s, int start, int end, int[][] dp){
	if(start == end || isPalindrome(s,start,end)){
		return dp[start][end] = 0;
	}
	if(dp[start][end] != -1){
		return dp[start][end];
	}
	int cuts = Integer.MAX_VALUE;
	for(int i = start; i < end; i++){
		// cut at i 
		int curr = 1 + helper(s,start,i,dp) + helper(s,i+1,end,dp);
		if(cuts > curr){
			cuts = curr;
		}
	}
	return dp[start][end] = cuts;
}

boolean isPalindrome(String s, int start, int end){
	while(start <= end){
		if(s.charAt(start) == s.charAt(end)){
			start++;
			end--;
		}
		else{
			return false;
		}
	}
	return true;
}

BETTER APPROACH

Logic: This can be solved by two points:
1. cut[i] is the minimum of cut[j - 1] + 1 (j <= i), if [j, i] is palindrome.
2. If [j, i] is palindrome, [j + 1, i - 1] is palindrome, and c[j] == c[i].

Time: O(N^2), Space: O(N^2)

public int minCut(String s) {
	int n = s.length();
	char[] c = s.toCharArray();
	boolean[][] pal = new boolean[n+1][n+1];
	int[] cuts = new int[n];
	
	for(int i = 0; i < n; i++){
		int min = i; // max cuts which we can get.
		for(int j = 0; j <= i; j++){
			if(c[j] == c[i] && (j+1 > i-1 || pal[j+1][i-1])){ // if palindrome
				pal[j][i] = true;
				// check what were the min cuts till (j-1)th index and add 1 because we will have one cut after that.
				// base condition: j == 0 then we don't need to cut infront of j-1, so it is 0.
				min = j == 0 ? 0 : Math.min(min,cuts[j-1]+1);
			}
		}
		cuts[i] = min;
	}
	
	return cuts[n-1];
}



BIT MANIPULATION

1. Check if a number if a power of 2 or not in O(1) 

Shortcut --> n&(n-1) == 0

Time: O(32), Space: O(1)

public boolean isPowerOfTwo(int n) {
	if(n <= 0) return false;
	int count = 0;
	for(int i = 0; i < 32; i++){
		if((n&(1<<i)) != 0) count++;
	}
	return count == 1 ? true : false;
}

2. Count total set bits 

3. Divide Integers without / operator 

4. Power Set (this is very important) 

5. Find MSB in o(1) 

6. Find LSB in o(1) 
	int lsb = xor & ~(xor-1);

7. Find square of a number without using multiplication or division operators.  


IMPLEMENTATIONS:

-> TRIE Implementation

class Node{
	Node[] arr = new Node[26];
	boolean flag;
}

Node root = new Node();

-> Fenwick Tree Implementation [VERY IMP]

// fenwick tree for sum query with 1 based indexing
int N = 1000;
int[] fen = new int[N];

public void update(int i, int val, int n){
    while(i < n){
        fen[i] += val;
        i = i + (i&(-i));
    }
}

public int sum(int r){
    int count = 0;
    while(r > 0){
        count += fen[r];
        r = r - (r&(-r));
    }
    return count;
}

-> Internal Working of HashMap

HashMap is an array of Node where Node has attributes: int hash, K key, V value, Node next.

Hash Function
For Int-> We can use %m (mod m).
For String -> We can use s[0]*(p^0) + s[1]*(p^1) + .. where p is prime number.
For Object -> Sum of attributes. or user hashCode() of java.
		
		0  1 2  3 4 5
Keys -> 12 2 13 9 4 8
here m is size of the keys.

And we create hashmap by this:
Node[] hashmap = new Node[m];

Node{
	int hash;
	K key;
	V value;
	Node next;
}

Storage
Idx  Nodes
0 -> 12
1 -> 13
2 -> 2 -> 8
3 -> 9
4 -> 4
5

Time: O(1 + size) // size of the nodes depends on hash function.
Space: O(M)

To tackle the huge size problem, in java we create self balancing binary search tree. And because of this time becomes O(1 + log(size)).

Load Factor: Whenever the size of object gets equals to load factor then we double the size of the HashMap's Nodes array. In java load factor is 0.75.


-> HEAP Implementation:


